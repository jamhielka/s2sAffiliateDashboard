{"remainingRequest":"D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\babel-loader\\lib\\index.js!D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\cache-loader\\dist\\cjs.js??ref--1-0!D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\vue2-timepicker\\src\\vue-timepicker.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\vue2-timepicker\\src\\vue-timepicker.vue","mtime":1648767944082},{"path":"D:\\JK2L2\\BUCKET\\s2sTracker\\babel.config.js","mtime":1648769491690},{"path":"D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1648193571030},{"path":"D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\babel-loader\\lib\\index.js","mtime":1648193571283},{"path":"D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1648193571030},{"path":"D:\\JK2L2\\BUCKET\\s2sTracker\\node_modules\\vue-loader\\lib\\index.js","mtime":1648193599351}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90eXBlb2YgZnJvbSAiRDovSksyTDIvQlVDS0VUL3Myc1RyYWNrZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcyI7CmltcG9ydCBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciBmcm9tICJEOi9KSzJMMi9CVUNLRVQvczJzVHJhY2tlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmpzb24uc3RyaW5naWZ5LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNvcnQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmRvdC1hbGwuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuc3RpY2t5LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC1hbGwuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudGVzdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC1pbmRleC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qcyI7CnZhciBDT05GSUcgPSB7CiAgSE9VUl9UT0tFTlM6IFsnSEgnLCAnSCcsICdoaCcsICdoJywgJ2trJywgJ2snXSwKICBNSU5VVEVfVE9LRU5TOiBbJ21tJywgJ20nXSwKICBTRUNPTkRfVE9LRU5TOiBbJ3NzJywgJ3MnXSwKICBBUE1fVE9LRU5TOiBbJ0EnLCAnYSddLAogIEJBU0lDX1RZUEVTOiBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdhcG0nXQp9Owp2YXIgREVGQVVMVF9PUFRJT05TID0gewogIGZvcm1hdDogJ0hIOm1tJywKICBtaW51dGVJbnRlcnZhbDogMSwKICBzZWNvbmRJbnRlcnZhbDogMSwKICBob3VyUmFuZ2U6IG51bGwsCiAgbWludXRlUmFuZ2U6IG51bGwsCiAgc2Vjb25kUmFuZ2U6IG51bGwsCiAgaGlkZURpc2FibGVkSG91cnM6IGZhbHNlLAogIGhpZGVEaXNhYmxlZE1pbnV0ZXM6IGZhbHNlLAogIGhpZGVEaXNhYmxlZFNlY29uZHM6IGZhbHNlLAogIGhpZGVEaXNhYmxlZEl0ZW1zOiBmYWxzZSwKICBoaWRlRHJvcGRvd246IGZhbHNlLAogIGJsdXJEZWxheTogMzAwLAogIG1hbnVhbElucHV0VGltZW91dDogMTAwMCwKICBkcm9wT2Zmc2V0SGVpZ2h0OiAxNjAKfTsKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdWdWVUaW1lcGlja2VyJywKICBwcm9wczogewogICAgdmFsdWU6IHsKICAgICAgdHlwZTogW09iamVjdCwgU3RyaW5nXQogICAgfSwKICAgIGZvcm1hdDogewogICAgICB0eXBlOiBTdHJpbmcKICAgIH0sCiAgICBtaW51dGVJbnRlcnZhbDogewogICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddCiAgICB9LAogICAgc2Vjb25kSW50ZXJ2YWw6IHsKICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXQogICAgfSwKICAgIGhvdXJSYW5nZTogewogICAgICB0eXBlOiBBcnJheQogICAgfSwKICAgIG1pbnV0ZVJhbmdlOiB7CiAgICAgIHR5cGU6IEFycmF5CiAgICB9LAogICAgc2Vjb25kUmFuZ2U6IHsKICAgICAgdHlwZTogQXJyYXkKICAgIH0sCiAgICBoaWRlRGlzYWJsZWRIb3VyczogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIGhpZGVEaXNhYmxlZE1pbnV0ZXM6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICBoaWRlRGlzYWJsZWRTZWNvbmRzOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9LAogICAgaGlkZURpc2FibGVkSXRlbXM6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICBoaWRlQ2xlYXJCdXR0b246IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICBkaXNhYmxlZDogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIGNsb3NlT25Db21wbGV0ZTogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIGlkOiB7CiAgICAgIHR5cGU6IFN0cmluZwogICAgfSwKICAgIG5hbWU6IHsKICAgICAgdHlwZTogU3RyaW5nCiAgICB9LAogICAgaW5wdXRDbGFzczogewogICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3QsIEFycmF5XQogICAgfSwKICAgIHBsYWNlaG9sZGVyOiB7CiAgICAgIHR5cGU6IFN0cmluZwogICAgfSwKICAgIHRhYmluZGV4OiB7CiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sCiAgICAgIGRlZmF1bHQ6IDAKICAgIH0sCiAgICBpbnB1dFdpZHRoOiB7CiAgICAgIHR5cGU6IFN0cmluZwogICAgfSwKICAgIGF1dG9jb21wbGV0ZTogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICdvZmYnCiAgICB9LAogICAgaG91ckxhYmVsOiB7CiAgICAgIHR5cGU6IFN0cmluZwogICAgfSwKICAgIG1pbnV0ZUxhYmVsOiB7CiAgICAgIHR5cGU6IFN0cmluZwogICAgfSwKICAgIHNlY29uZExhYmVsOiB7CiAgICAgIHR5cGU6IFN0cmluZwogICAgfSwKICAgIGFwbUxhYmVsOiB7CiAgICAgIHR5cGU6IFN0cmluZwogICAgfSwKICAgIGFtVGV4dDogewogICAgICB0eXBlOiBTdHJpbmcKICAgIH0sCiAgICBwbVRleHQ6IHsKICAgICAgdHlwZTogU3RyaW5nCiAgICB9LAogICAgYmx1ckRlbGF5OiB7CiAgICAgIHR5cGU6IFtOdW1iZXIsIFN0cmluZ10KICAgIH0sCiAgICBhZHZhbmNlZEtleWJvYXJkOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9LAogICAgbGF6eTogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIGF1dG9TY3JvbGw6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICBkcm9wRGlyZWN0aW9uOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogJ2Rvd24nCiAgICB9LAogICAgZHJvcE9mZnNldEhlaWdodDogewogICAgICB0eXBlOiBbTnVtYmVyLCBTdHJpbmddCiAgICB9LAogICAgY29udGFpbmVySWQ6IHsKICAgICAgdHlwZTogU3RyaW5nCiAgICB9LAogICAgYXBwZW5kVG9Cb2R5OiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9LAogICAgbWFudWFsSW5wdXQ6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICBtYW51YWxJbnB1dFRpbWVvdXQ6IHsKICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXQogICAgfSwKICAgIGhpZGVEcm9wZG93bjogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIGZpeGVkRHJvcGRvd25CdXR0b246IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICBkZWJ1Z01vZGU6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0KICB9LAogIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICB0aW1lVmFsdWU6IHt9LAogICAgICBob3VyczogW10sCiAgICAgIG1pbnV0ZXM6IFtdLAogICAgICBzZWNvbmRzOiBbXSwKICAgICAgYXBtczogW10sCiAgICAgIGlzQWN0aXZlOiBmYWxzZSwKICAgICAgc2hvd0Ryb3Bkb3duOiBmYWxzZSwKICAgICAgaXNGb2N1c2luZzogZmFsc2UsCiAgICAgIGRlYm91bmNlVGltZXI6IHVuZGVmaW5lZCwKICAgICAgaG91clR5cGU6ICdISCcsCiAgICAgIG1pbnV0ZVR5cGU6ICdtbScsCiAgICAgIHNlY29uZFR5cGU6ICcnLAogICAgICBhcG1UeXBlOiAnJywKICAgICAgaG91cjogJycsCiAgICAgIG1pbnV0ZTogJycsCiAgICAgIHNlY29uZDogJycsCiAgICAgIGFwbTogJycsCiAgICAgIGZ1bGxWYWx1ZXM6IHVuZGVmaW5lZCwKICAgICAgYmFrRGlzcGxheVRpbWU6IHVuZGVmaW5lZCwKICAgICAgZG9DbGVhckFwbUNoZWNraW5nOiBmYWxzZSwKICAgICAgc2VsZWN0aW9uVGltZXI6IHVuZGVmaW5lZCwKICAgICAga2JJbnB1dFRpbWVyOiB1bmRlZmluZWQsCiAgICAgIGtiSW5wdXRMb2c6ICcnLAogICAgICBiYWtDdXJyZW50UG9zOiB1bmRlZmluZWQsCiAgICAgIGZvcmNlRHJvcE9uVG9wOiBmYWxzZQogICAgfTsKICB9LAogIGNvbXB1dGVkOiB7CiAgICBvcHRzOiBmdW5jdGlvbiBvcHRzKCkgewogICAgICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyk7CgogICAgICBpZiAodGhpcy5mb3JtYXQgJiYgdGhpcy5mb3JtYXQubGVuZ3RoKSB7CiAgICAgICAgb3B0aW9ucy5mb3JtYXQgPSBTdHJpbmcodGhpcy5mb3JtYXQpOwogICAgICB9CgogICAgICBpZiAodGhpcy5pc051bWJlcih0aGlzLm1pbnV0ZUludGVydmFsKSkgewogICAgICAgIG9wdGlvbnMubWludXRlSW50ZXJ2YWwgPSArdGhpcy5taW51dGVJbnRlcnZhbDsKICAgICAgfSAvLyBtaW51dGVJbnRlcnZhbCBmYWlsc2FmZQoKCiAgICAgIGlmICghb3B0aW9ucy5taW51dGVJbnRlcnZhbCB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsIDwgMSB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsID4gNjApIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIGlmIChvcHRpb25zLm1pbnV0ZUludGVydmFsID4gNjApIHsKICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygiXCJtaW51dGUtaW50ZXJ2YWxcIiBzaG91bGQgYmUgbGVzcyB0aGFuIDYwLiBDdXJyZW50IHZhbHVlIGlzICIuY29uY2F0KHRoaXMubWludXRlSW50ZXJ2YWwpKTsKICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5taW51dGVJbnRlcnZhbCA9PT0gMCB8fCBvcHRpb25zLm1pbnV0ZUludGVydmFsIDwgMSkgewogICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCJcIm1pbnV0ZS1pbnRlcnZhbFwiIHNob3VsZCBiZSBOTyBsZXNzIHRoYW4gMS4gQ3VycmVudCB2YWx1ZSBpcyAiLmNvbmNhdCh0aGlzLm1pbnV0ZUludGVydmFsKSk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAob3B0aW9ucy5taW51dGVJbnRlcnZhbCA9PT0gMCkgewogICAgICAgICAgb3B0aW9ucy5taW51dGVJbnRlcnZhbCA9IDYwOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvcHRpb25zLm1pbnV0ZUludGVydmFsID0gMTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmlzTnVtYmVyKHRoaXMuc2Vjb25kSW50ZXJ2YWwpKSB7CiAgICAgICAgb3B0aW9ucy5zZWNvbmRJbnRlcnZhbCA9ICt0aGlzLnNlY29uZEludGVydmFsOwogICAgICB9IC8vIHNlY29uZEludGVydmFsIGZhaWxzYWZlCgoKICAgICAgaWYgKCFvcHRpb25zLnNlY29uZEludGVydmFsIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPCAxIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPiA2MCkgewogICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgaWYgKG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPiA2MCkgewogICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCJcInNlY29uZC1pbnRlcnZhbFwiIHNob3VsZCBiZSBsZXNzIHRoYW4gNjAuIEN1cnJlbnQgdmFsdWUgaXMgIi5jb25jYXQodGhpcy5zZWNvbmRJbnRlcnZhbCkpOwogICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNlY29uZEludGVydmFsID09PSAwIHx8IG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPCAxKSB7CiAgICAgICAgICAgIHRoaXMuZGVidWdMb2coIlwic2Vjb25kLWludGVydmFsXCIgc2hvdWxkIGJlIE5PIGxlc3MgdGhhbiAxLiBDdXJyZW50IHZhbHVlIGlzICIuY29uY2F0KHRoaXMuc2Vjb25kSW50ZXJ2YWwpKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChvcHRpb25zLnNlY29uZEludGVydmFsID09PSAwKSB7CiAgICAgICAgICBvcHRpb25zLnNlY29uZEludGVydmFsID0gNjA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG9wdGlvbnMuc2Vjb25kSW50ZXJ2YWwgPSAxOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuaG91clJhbmdlICYmIEFycmF5LmlzQXJyYXkodGhpcy5ob3VyUmFuZ2UpKSB7CiAgICAgICAgb3B0aW9ucy5ob3VyUmFuZ2UgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuaG91clJhbmdlKSk7CgogICAgICAgIGlmICghdGhpcy5ob3VyUmFuZ2UubGVuZ3RoICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgImhvdXItcmFuZ2UiIGFycmF5IGlzIGVtcHR5IChsZW5ndGggPT09IDApJyk7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAodGhpcy5taW51dGVSYW5nZSAmJiBBcnJheS5pc0FycmF5KHRoaXMubWludXRlUmFuZ2UpKSB7CiAgICAgICAgb3B0aW9ucy5taW51dGVSYW5nZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5taW51dGVSYW5nZSkpOwoKICAgICAgICBpZiAoIXRoaXMubWludXRlUmFuZ2UubGVuZ3RoICYmIHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgIm1pbnV0ZS1yYW5nZSIgYXJyYXkgaXMgZW1wdHkgKGxlbmd0aCA9PT0gMCknKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLnNlY29uZFJhbmdlICYmIEFycmF5LmlzQXJyYXkodGhpcy5zZWNvbmRSYW5nZSkpIHsKICAgICAgICBvcHRpb25zLnNlY29uZFJhbmdlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnNlY29uZFJhbmdlKSk7CgogICAgICAgIGlmICghdGhpcy5zZWNvbmRSYW5nZS5sZW5ndGggJiYgdGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coJ1RoZSAic2Vjb25kLXJhbmdlIiBhcnJheSBpcyBlbXB0eSAobGVuZ3RoID09PSAwKScpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICBvcHRpb25zLmhpZGVEaXNhYmxlZEl0ZW1zID0gdHJ1ZTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuaGlkZURpc2FibGVkSG91cnMgfHwgdGhpcy5oaWRlRGlzYWJsZWRJdGVtcykgewogICAgICAgIG9wdGlvbnMuaGlkZURpc2FibGVkSG91cnMgPSB0cnVlOwogICAgICB9CgogICAgICBpZiAodGhpcy5oaWRlRGlzYWJsZWRNaW51dGVzIHx8IHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICBvcHRpb25zLmhpZGVEaXNhYmxlZE1pbnV0ZXMgPSB0cnVlOwogICAgICB9CgogICAgICBpZiAodGhpcy5oaWRlRGlzYWJsZWRTZWNvbmRzIHx8IHRoaXMuaGlkZURpc2FibGVkSXRlbXMpIHsKICAgICAgICBvcHRpb25zLmhpZGVEaXNhYmxlZFNlY29uZHMgPSB0cnVlOwogICAgICB9CgogICAgICBpZiAodGhpcy5oaWRlRHJvcGRvd24pIHsKICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgICAgb3B0aW9ucy5oaWRlRHJvcGRvd24gPSB0cnVlOwogICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coJyJoaWRlLWRyb3Bkb3duIiBvbmx5IHdvcmtzIHdpdGggIm1hbnVhbC1pbnB1dCIgbW9kZScpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMuYmx1ckRlbGF5ICYmICt0aGlzLmJsdXJEZWxheSA+IDApIHsKICAgICAgICBvcHRpb25zLmJsdXJEZWxheSA9ICt0aGlzLmJsdXJEZWxheTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXRUaW1lb3V0ICYmICt0aGlzLm1hbnVhbElucHV0VGltZW91dCA+IDApIHsKICAgICAgICBvcHRpb25zLm1hbnVhbElucHV0VGltZW91dCA9ICt0aGlzLm1hbnVhbElucHV0VGltZW91dDsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuZHJvcE9mZnNldEhlaWdodCAmJiArdGhpcy5kcm9wT2Zmc2V0SGVpZ2h0ID4gMCkgewogICAgICAgIG9wdGlvbnMuZHJvcE9mZnNldEhlaWdodCA9ICt0aGlzLmRyb3BPZmZzZXRIZWlnaHQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBvcHRpb25zOwogICAgfSwKICAgIHVzZVN0cmluZ1ZhbHVlOiBmdW5jdGlvbiB1c2VTdHJpbmdWYWx1ZSgpIHsKICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbHVlID09PSAnc3RyaW5nJzsKICAgIH0sCiAgICBmb3JtYXRTdHJpbmc6IGZ1bmN0aW9uIGZvcm1hdFN0cmluZygpIHsKICAgICAgcmV0dXJuIHRoaXMub3B0cy5mb3JtYXQgfHwgREVGQVVMVF9PUFRJT05TLmZvcm1hdDsKICAgIH0sCiAgICBpblVzZTogZnVuY3Rpb24gaW5Vc2UoKSB7CiAgICAgIHZhciBfdGhpcyA9IHRoaXM7CgogICAgICB2YXIgdHlwZXNJblVzZSA9IENPTkZJRy5CQVNJQ19UWVBFUy5maWx0ZXIoZnVuY3Rpb24gKHR5cGUpIHsKICAgICAgICByZXR1cm4gX3RoaXMuZ2V0VG9rZW5CeVR5cGUodHlwZSk7CiAgICAgIH0pOyAvLyBTb3J0IHR5cGVzIGFuZCB0b2tlbnMgYnkgdGhlaXIgc2VxdWVuY2UgaW4gdGhlICJmb3JtYXQiIHN0cmluZwoKICAgICAgdHlwZXNJblVzZS5zb3J0KGZ1bmN0aW9uIChsLCByKSB7CiAgICAgICAgcmV0dXJuIF90aGlzLmZvcm1hdFN0cmluZy5pbmRleE9mKF90aGlzLmdldFRva2VuQnlUeXBlKGwpIHx8IG51bGwpIC0gX3RoaXMuZm9ybWF0U3RyaW5nLmluZGV4T2YoX3RoaXMuZ2V0VG9rZW5CeVR5cGUocikgfHwgbnVsbCk7CiAgICAgIH0pOwogICAgICB2YXIgdG9rZW5zSW5Vc2UgPSB0eXBlc0luVXNlLm1hcChmdW5jdGlvbiAodHlwZSkgewogICAgICAgIHJldHVybiBfdGhpcy5nZXRUb2tlbkJ5VHlwZSh0eXBlKTsKICAgICAgfSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgaG91cjogISF0aGlzLmhvdXJUeXBlLAogICAgICAgIG1pbnV0ZTogISF0aGlzLm1pbnV0ZVR5cGUsCiAgICAgICAgc2Vjb25kOiAhIXRoaXMuc2Vjb25kVHlwZSwKICAgICAgICBhcG06ICEhdGhpcy5hcG1UeXBlLAogICAgICAgIHR5cGVzOiB0eXBlc0luVXNlIHx8IFtdLAogICAgICAgIHRva2VuczogdG9rZW5zSW5Vc2UgfHwgW10KICAgICAgfTsKICAgIH0sCiAgICBkaXNwbGF5VGltZTogZnVuY3Rpb24gZGlzcGxheVRpbWUoKSB7CiAgICAgIHZhciBmb3JtYXRTdHJpbmcgPSBTdHJpbmcodGhpcy5mb3JtYXRTdHJpbmcpOwoKICAgICAgaWYgKHRoaXMuaG91cikgewogICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5ob3VyVHlwZSwgJ2cnKSwgdGhpcy5ob3VyKTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMubWludXRlKSB7CiAgICAgICAgZm9ybWF0U3RyaW5nID0gZm9ybWF0U3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm1pbnV0ZVR5cGUsICdnJyksIHRoaXMubWludXRlKTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuc2Vjb25kICYmIHRoaXMuc2Vjb25kVHlwZSkgewogICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5zZWNvbmRUeXBlLCAnZycpLCB0aGlzLnNlY29uZCk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmFwbSAmJiB0aGlzLmFwbVR5cGUpIHsKICAgICAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMuYXBtVHlwZSwgJ2cnKSwgdGhpcy5hcG0pOwogICAgICB9CgogICAgICByZXR1cm4gZm9ybWF0U3RyaW5nOwogICAgfSwKICAgIGN1c3RvbURpc3BsYXlUaW1lOiBmdW5jdGlvbiBjdXN0b21EaXNwbGF5VGltZSgpIHsKICAgICAgaWYgKCF0aGlzLmFtVGV4dCAmJiAhdGhpcy5wbVRleHQpIHsKICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5VGltZTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVRpbWUucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMuYXBtLCAnZycpLCB0aGlzLmFwbURpc3BsYXlUZXh0KHRoaXMuYXBtKSk7CiAgICB9LAogICAgaW5wdXRJc0VtcHR5OiBmdW5jdGlvbiBpbnB1dElzRW1wdHkoKSB7CiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFN0cmluZyA9PT0gdGhpcy5kaXNwbGF5VGltZTsKICAgIH0sCiAgICBhbGxWYWx1ZVNlbGVjdGVkOiBmdW5jdGlvbiBhbGxWYWx1ZVNlbGVjdGVkKCkgewogICAgICBpZiAodGhpcy5pblVzZS5ob3VyICYmICF0aGlzLmhvdXIgfHwgdGhpcy5pblVzZS5taW51dGUgJiYgIXRoaXMubWludXRlIHx8IHRoaXMuaW5Vc2Uuc2Vjb25kICYmICF0aGlzLnNlY29uZCB8fCB0aGlzLmluVXNlLmFwbSAmJiAhdGhpcy5hcG0pIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfSwKICAgIGNvbHVtbnNTZXF1ZW5jZTogZnVuY3Rpb24gY29sdW1uc1NlcXVlbmNlKCkgewogICAgICByZXR1cm4gdGhpcy5pblVzZS50eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsKICAgICAgICByZXR1cm4gdHlwZTsKICAgICAgfSkgfHwgW107CiAgICB9LAogICAgc2hvd0NsZWFyQnRuOiBmdW5jdGlvbiBzaG93Q2xlYXJCdG4oKSB7CiAgICAgIGlmICh0aGlzLmhpZGVDbGVhckJ1dHRvbiB8fCB0aGlzLmRpc2FibGVkKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gIXRoaXMuaW5wdXRJc0VtcHR5OwogICAgfSwKICAgIHNob3dEcm9wZG93bkJ0bjogZnVuY3Rpb24gc2hvd0Ryb3Bkb3duQnRuKCkgewogICAgICBpZiAodGhpcy5maXhlZERyb3Bkb3duQnV0dG9uKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLm9wdHMuaGlkZURyb3Bkb3duICYmIHRoaXMuaXNBY3RpdmUgJiYgIXRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0sCiAgICBiYXNlT24xMkhvdXJzOiBmdW5jdGlvbiBiYXNlT24xMkhvdXJzKCkgewogICAgICByZXR1cm4gdGhpcy5ob3VyVHlwZSA9PT0gJ2gnIHx8IHRoaXMuaG91clR5cGUgPT09ICdoaCc7CiAgICB9LAogICAgaG91clJhbmdlSW4yNEhyRm9ybWF0OiBmdW5jdGlvbiBob3VyUmFuZ2VJbjI0SHJGb3JtYXQoKSB7CiAgICAgIHZhciBfdGhpczIgPSB0aGlzOwoKICAgICAgaWYgKCF0aGlzLmhvdXJUeXBlIHx8ICF0aGlzLm9wdHMuaG91clJhbmdlKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAoIXRoaXMub3B0cy5ob3VyUmFuZ2UubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICB2YXIgcmFuZ2UgPSBbXTsKICAgICAgdGhpcy5vcHRzLmhvdXJSYW5nZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7CiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMiAmJiBfdGhpczIuZGVidWdNb2RlKSB7CiAgICAgICAgICAgIF90aGlzMi5kZWJ1Z0xvZygiTmVzdGVkIGFycmF5IHdpdGhpbiBcImhvdXItcmFuZ2VcIiBtdXN0IGNvbnRhaW4gbm8gbW9yZSB0aGFuIHR3byBpdGVtcy4gT25seSB0aGUgZmlyc3QgdHdvIGl0ZW1zIG9mICIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgIiB3aWxsIGJlIHRha2VuIGludG8gYWNjb3VudC4iKSk7CiAgICAgICAgICB9CgogICAgICAgICAgdmFyIHN0YXJ0ID0gdmFsdWVbMF07CiAgICAgICAgICB2YXIgZW5kID0gdmFsdWVbMV0gfHwgdmFsdWVbMF07CgogICAgICAgICAgaWYgKF90aGlzMi5pczEyaFJhbmdlKHN0YXJ0KSkgewogICAgICAgICAgICBzdGFydCA9IF90aGlzMi50cmFuc2xhdGUxMmhSYW5nZShzdGFydCk7CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKF90aGlzMi5pczEyaFJhbmdlKGVuZCkpIHsKICAgICAgICAgICAgZW5kID0gX3RoaXMyLnRyYW5zbGF0ZTEyaFJhbmdlKGVuZCk7CiAgICAgICAgICB9CgogICAgICAgICAgZm9yICh2YXIgaSA9ICtzdGFydDsgaSA8PSArZW5kOyBpKyspIHsKICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPiAyNCkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoIXJhbmdlLmluY2x1ZGVzKGkpKSB7CiAgICAgICAgICAgICAgcmFuZ2UucHVzaChpKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoX3RoaXMyLmlzMTJoUmFuZ2UodmFsdWUpKSB7CiAgICAgICAgICAgIHZhbHVlID0gX3RoaXMyLnRyYW5zbGF0ZTEyaFJhbmdlKHZhbHVlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhbHVlID0gK3ZhbHVlOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAyNCkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CgogICAgICAgICAgaWYgKCFyYW5nZS5pbmNsdWRlcyh2YWx1ZSkpIHsKICAgICAgICAgICAgcmFuZ2UucHVzaCh2YWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KTsKICAgICAgcmFuZ2Uuc29ydChmdW5jdGlvbiAobCwgcikgewogICAgICAgIHJldHVybiBsIC0gcjsKICAgICAgfSk7CiAgICAgIHJldHVybiByYW5nZTsKICAgIH0sCiAgICByZXN0cmljdGVkSG91clJhbmdlOiBmdW5jdGlvbiByZXN0cmljdGVkSG91clJhbmdlKCkgewogICAgICAvLyBObyByZXN0cmljdGlvbgogICAgICBpZiAoIXRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0KSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9IC8vIDEyLUhvdXIKCgogICAgICBpZiAodGhpcy5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5ob3VyUmFuZ2VJbjI0SHJGb3JtYXQubWFwKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgaWYgKHZhbHVlID09PSAxMikgewogICAgICAgICAgICByZXR1cm4gJzEycCc7CiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAyNCB8fCB2YWx1ZSA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gJzEyYSc7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHZhbHVlID4gMTIgPyAiIi5jb25jYXQodmFsdWUgJSAxMiwgInAiKSA6ICIiLmNvbmNhdCh2YWx1ZSwgImEiKTsKICAgICAgICB9KTsKICAgICAgICByZXR1cm4gcmFuZ2U7CiAgICAgIH0gLy8gMjQtSG91cgoKCiAgICAgIHJldHVybiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdDsKICAgIH0sCiAgICB2YWxpZEhvdXJzTGlzdDogZnVuY3Rpb24gdmFsaWRIb3Vyc0xpc3QoKSB7CiAgICAgIHZhciBfdGhpczMgPSB0aGlzOwoKICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAodGhpcy5yZXN0cmljdGVkSG91clJhbmdlKSB7CiAgICAgICAgdmFyIGxpc3QgPSBbXTsKCiAgICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgICAgbGlzdCA9IHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5tYXAoZnVuY3Rpb24gKGhyKSB7CiAgICAgICAgICAgIHZhciBsID0gaHIuc3Vic3RyKDAsIGhyLmxlbmd0aCAtIDEpOwogICAgICAgICAgICB2YXIgciA9IGhyLnN1YnN0cigtMSk7CiAgICAgICAgICAgIHJldHVybiAiIi5jb25jYXQoX3RoaXMzLmZvcm1hdFZhbHVlKF90aGlzMy5ob3VyVHlwZSwgbCkpLmNvbmNhdChyKTsKICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIGFtMTJJbmRleCA9IGxpc3QuaW5kZXhPZignMTJhJyk7CgogICAgICAgICAgaWYgKGFtMTJJbmRleCA+IDApIHsKICAgICAgICAgICAgLy8gTWFrZSAnMTJhJyB0aGUgZmlyc3QgaXRlbSBpbiBoL2hoCiAgICAgICAgICAgIGxpc3QudW5zaGlmdChsaXN0LnNwbGljZShhbTEySW5kZXgsIDEpWzBdKTsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gbGlzdDsKICAgICAgICB9CgogICAgICAgIGxpc3QgPSB0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UubWFwKGZ1bmN0aW9uIChocikgewogICAgICAgICAgcmV0dXJuIF90aGlzMy5mb3JtYXRWYWx1ZShfdGhpczMuaG91clR5cGUsIGhyKTsKICAgICAgICB9KTsKCiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMSAmJiBsaXN0WzBdICYmIGxpc3RbMF0gPT09ICcyNCcpIHsKICAgICAgICAgIC8vIE1ha2UgJzI0JyB0aGUgbGFzdCBpdGVtIGluIGsva2sKICAgICAgICAgIGxpc3QucHVzaChsaXN0LnNoaWZ0KCkpOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGxpc3Q7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICByZXR1cm4gW10uY29uY2F0KFtdLCB0aGlzLmhvdXJzLm1hcChmdW5jdGlvbiAoaHIpIHsKICAgICAgICAgIHJldHVybiAiIi5jb25jYXQoaHIsICJhIik7CiAgICAgICAgfSksIHRoaXMuaG91cnMubWFwKGZ1bmN0aW9uIChocikgewogICAgICAgICAgcmV0dXJuICIiLmNvbmNhdChociwgInAiKTsKICAgICAgICB9KSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLmhvdXJzOwogICAgfSwKICAgIGhhczogZnVuY3Rpb24gaGFzKCkgewogICAgICB2YXIgcmVzdWx0ID0gewogICAgICAgIGN1c3RvbUFwbVRleHQ6IGZhbHNlCiAgICAgIH07CiAgICAgIHZhciBhcG1FbmFibGVkID0gISF0aGlzLmFwbVR5cGU7CgogICAgICBpZiAoYXBtRW5hYmxlZCAmJiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdCAmJiB0aGlzLmhvdXJSYW5nZUluMjRIckZvcm1hdC5sZW5ndGgpIHsKICAgICAgICB2YXIgcmFuZ2UgPSBbXS5jb25jYXQoW10sIHRoaXMuaG91clJhbmdlSW4yNEhyRm9ybWF0KTsKICAgICAgICByZXN1bHQuYW0gPSByYW5nZS5zb21lKGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIHZhbHVlIDwgMTIgfHwgdmFsdWUgPT09IDI0OwogICAgICAgIH0pOwogICAgICAgIHJlc3VsdC5wbSA9IHJhbmdlLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gMTIgJiYgdmFsdWUgPCAyNDsKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQuYW0gPSBhcG1FbmFibGVkOwogICAgICAgIHJlc3VsdC5wbSA9IGFwbUVuYWJsZWQ7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmFtVGV4dCAmJiB0aGlzLmFtVGV4dC5sZW5ndGggfHwgdGhpcy5wbVRleHQgJiYgdGhpcy5wbVRleHQubGVuZ3RoKSB7CiAgICAgICAgcmVzdWx0LmN1c3RvbUFwbVRleHQgPSB0cnVlOwogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfSwKICAgIG1pbnV0ZVJhbmdlTGlzdDogZnVuY3Rpb24gbWludXRlUmFuZ2VMaXN0KCkgewogICAgICBpZiAoIXRoaXMubWludXRlVHlwZSB8fCAhdGhpcy5vcHRzLm1pbnV0ZVJhbmdlKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAoIXRoaXMub3B0cy5taW51dGVSYW5nZS5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gW107CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLnJlbmRlclJhbmdlTGlzdCh0aGlzLm9wdHMubWludXRlUmFuZ2UsICdtaW51dGUnKTsKICAgIH0sCiAgICBzZWNvbmRSYW5nZUxpc3Q6IGZ1bmN0aW9uIHNlY29uZFJhbmdlTGlzdCgpIHsKICAgICAgaWYgKCF0aGlzLnNlY29uZFR5cGUgfHwgIXRoaXMub3B0cy5zZWNvbmRSYW5nZSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgaWYgKCF0aGlzLm9wdHMuc2Vjb25kUmFuZ2UubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5yZW5kZXJSYW5nZUxpc3QodGhpcy5vcHRzLnNlY29uZFJhbmdlLCAnc2Vjb25kJyk7CiAgICB9LAogICAgaG91ckxhYmVsVGV4dDogZnVuY3Rpb24gaG91ckxhYmVsVGV4dCgpIHsKICAgICAgcmV0dXJuIHRoaXMuaG91ckxhYmVsIHx8IHRoaXMuaG91clR5cGU7CiAgICB9LAogICAgbWludXRlTGFiZWxUZXh0OiBmdW5jdGlvbiBtaW51dGVMYWJlbFRleHQoKSB7CiAgICAgIHJldHVybiB0aGlzLm1pbnV0ZUxhYmVsIHx8IHRoaXMubWludXRlVHlwZTsKICAgIH0sCiAgICBzZWNvbmRMYWJlbFRleHQ6IGZ1bmN0aW9uIHNlY29uZExhYmVsVGV4dCgpIHsKICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kTGFiZWwgfHwgdGhpcy5zZWNvbmRUeXBlOwogICAgfSwKICAgIGFwbUxhYmVsVGV4dDogZnVuY3Rpb24gYXBtTGFiZWxUZXh0KCkgewogICAgICByZXR1cm4gdGhpcy5hcG1MYWJlbCB8fCB0aGlzLmFwbVR5cGU7CiAgICB9LAogICAgaW5wdXRXaWR0aFN0eWxlOiBmdW5jdGlvbiBpbnB1dFdpZHRoU3R5bGUoKSB7CiAgICAgIGlmICghdGhpcy5pbnB1dFdpZHRoIHx8ICF0aGlzLmlucHV0V2lkdGgubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICByZXR1cm4gewogICAgICAgIHdpZHRoOiB0aGlzLmlucHV0V2lkdGgKICAgICAgfTsKICAgIH0sCiAgICB0b2tlblJlZ2V4QmFzZTogZnVuY3Rpb24gdG9rZW5SZWdleEJhc2UoKSB7CiAgICAgIHJldHVybiB0aGlzLmluVXNlLnRva2Vucy5qb2luKCd8Jyk7CiAgICB9LAogICAgdG9rZW5DaHVua3M6IGZ1bmN0aW9uIHRva2VuQ2h1bmtzKCkgewogICAgICBpZiAoIXRoaXMubWFudWFsSW5wdXQgJiYgIXRoaXMudXNlU3RyaW5nVmFsdWUpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciBmb3JtYXRTdHJpbmcgPSBTdHJpbmcodGhpcy5mb3JtYXRTdHJpbmcpOwogICAgICB2YXIgdG9rZW5zUmVneFN0ciA9ICIoIi5jb25jYXQodGhpcy50b2tlblJlZ2V4QmFzZSwgIikrPyIpOwogICAgICB2YXIgdG9rZW5zTWF0Y2hBbGwgPSB0aGlzLmdldE1hdGNoQWxsQnlSZWdleChmb3JtYXRTdHJpbmcsIHRva2Vuc1JlZ3hTdHIpOwogICAgICB2YXIgdG9rZW5DaHVua3MgPSBbXTsKCiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0b2tlbnNNYXRjaEFsbCksCiAgICAgICAgICBfc3RlcDsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciB0a01hdGNoID0gX3N0ZXAudmFsdWU7CiAgICAgICAgICB2YXIgcmF3VG9rZW4gPSB0a01hdGNoWzBdOwogICAgICAgICAgdmFyIHRva2VuTWF0Y2hJdGVtID0gewogICAgICAgICAgICBpbmRleDogdGtNYXRjaC5pbmRleCwKICAgICAgICAgICAgdG9rZW46IHJhd1Rva2VuLAogICAgICAgICAgICB0eXBlOiB0aGlzLmdldFRva2VuVHlwZShyYXdUb2tlbiksCiAgICAgICAgICAgIG5lZWRzQ2FsaWJyYXRlOiByYXdUb2tlbi5sZW5ndGggPCAyLAogICAgICAgICAgICBsZW46IChyYXdUb2tlbiB8fCAnJykubGVuZ3RoCiAgICAgICAgICB9OwogICAgICAgICAgdG9rZW5DaHVua3MucHVzaCh0b2tlbk1hdGNoSXRlbSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IuZShlcnIpOwogICAgICB9IGZpbmFsbHkgewogICAgICAgIF9pdGVyYXRvci5mKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0b2tlbkNodW5rczsKICAgIH0sCiAgICBuZWVkc1Bvc0NhbGlicmF0ZTogZnVuY3Rpb24gbmVlZHNQb3NDYWxpYnJhdGUoKSB7CiAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXMudG9rZW5DaHVua3Muc29tZShmdW5jdGlvbiAoY2hrKSB7CiAgICAgICAgcmV0dXJuIGNoay5uZWVkc0NhbGlicmF0ZTsKICAgICAgfSk7CiAgICB9LAogICAgdG9rZW5DaHVua3NQb3M6IGZ1bmN0aW9uIHRva2VuQ2h1bmtzUG9zKCkgewogICAgICB2YXIgX3RoaXM0ID0gdGhpczsKCiAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgaWYgKCF0aGlzLm5lZWRzUG9zQ2FsaWJyYXRlKSB7CiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5DaHVua3MubWFwKGZ1bmN0aW9uIChjaGspIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHRva2VuOiBjaGsudG9rZW4sCiAgICAgICAgICAgIHR5cGU6IGNoay50eXBlLAogICAgICAgICAgICBzdGFydDogY2hrLmluZGV4LAogICAgICAgICAgICBlbmQ6IGNoay5pbmRleCArIGNoay5sZW4KICAgICAgICAgIH07CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHZhciBsaXN0ID0gW107CiAgICAgIHZhciBjYWxpYnJhdGVMZW4gPSAwOwogICAgICB0aGlzLnRva2VuQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNoaykgewogICAgICAgIHZhciBjaHVua0N1cnJlbnRMZW47IC8vIEFkanVzdCBmb3IgY3VzdG9taXplZCBBTS9QTSB0ZXh0CgogICAgICAgIGlmIChjaGsudHlwZSA9PT0gJ2FwbScgJiYgX3RoaXM0Lmhhcy5jdXN0b21BcG1UZXh0KSB7CiAgICAgICAgICBpZiAoX3RoaXM0LmFwbSAmJiBfdGhpczQuYXBtLmxlbmd0aCkgewogICAgICAgICAgICB2YXIgY3VzdG9tQXBtVGV4dCA9IF90aGlzNC5hcG0udG9Mb3dlckNhc2UoKSA9PT0gJ2FtJyA/IF90aGlzNC5hbVRleHQgOiBfdGhpczQucG1UZXh0OwogICAgICAgICAgICBjaHVua0N1cnJlbnRMZW4gPSBjdXN0b21BcG1UZXh0ICYmIGN1c3RvbUFwbVRleHQubGVuZ3RoID8gY3VzdG9tQXBtVGV4dC5sZW5ndGggOiBjaGsubGVuOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY2h1bmtDdXJyZW50TGVuID0gY2hrLmxlbjsKICAgICAgICAgIH0gLy8gT3RoZXJzCgogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjaHVua0N1cnJlbnRMZW4gPSBfdGhpczRbY2hrLnR5cGVdICYmIF90aGlzNFtjaGsudHlwZV0ubGVuZ3RoID8gX3RoaXM0W2Noay50eXBlXS5sZW5ndGggOiBjaGsubGVuOwogICAgICAgIH0KCiAgICAgICAgbGlzdC5wdXNoKHsKICAgICAgICAgIHRva2VuOiBjaGsudG9rZW4sCiAgICAgICAgICB0eXBlOiBjaGsudHlwZSwKICAgICAgICAgIHN0YXJ0OiBjaGsuaW5kZXggKyBjYWxpYnJhdGVMZW4sCiAgICAgICAgICBlbmQ6IGNoay5pbmRleCArIGNhbGlicmF0ZUxlbiArIGNodW5rQ3VycmVudExlbgogICAgICAgIH0pOwoKICAgICAgICBpZiAoY2hrLm5lZWRzQ2FsaWJyYXRlICYmIGNodW5rQ3VycmVudExlbiA+IGNoay5sZW4pIHsKICAgICAgICAgIGNhbGlicmF0ZUxlbiArPSBjaHVua0N1cnJlbnRMZW4gLSBjaGsubGVuOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHJldHVybiBsaXN0OwogICAgfSwKICAgIGludmFsaWRWYWx1ZXM6IGZ1bmN0aW9uIGludmFsaWRWYWx1ZXMoKSB7CiAgICAgIGlmICh0aGlzLmlucHV0SXNFbXB0eSkgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQoKICAgICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UgJiYgIXRoaXMubWludXRlUmFuZ2VMaXN0ICYmICF0aGlzLnNlY29uZFJhbmdlTGlzdCAmJiB0aGlzLm9wdHMubWludXRlSW50ZXJ2YWwgPT09IDEgJiYgdGhpcy5vcHRzLnNlY29uZEludGVydmFsID09PSAxKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICB2YXIgcmVzdWx0ID0gW107CgogICAgICBpZiAodGhpcy5pblVzZS5ob3VyICYmICF0aGlzLmlzRW1wdHlWYWx1ZSh0aGlzLmhvdXJUeXBlLCB0aGlzLmhvdXIpICYmICghdGhpcy5pc1ZhbGlkVmFsdWUodGhpcy5ob3VyVHlwZSwgdGhpcy5ob3VyKSB8fCB0aGlzLmlzRGlzYWJsZWQoJ2hvdXInLCB0aGlzLmhvdXIpKSkgewogICAgICAgIHJlc3VsdC5wdXNoKCdob3VyJyk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmluVXNlLm1pbnV0ZSAmJiAhdGhpcy5pc0VtcHR5VmFsdWUodGhpcy5taW51dGVUeXBlLCB0aGlzLm1pbnV0ZSkgJiYgKCF0aGlzLmlzVmFsaWRWYWx1ZSh0aGlzLm1pbnV0ZVR5cGUsIHRoaXMubWludXRlKSB8fCB0aGlzLmlzRGlzYWJsZWQoJ21pbnV0ZScsIHRoaXMubWludXRlKSB8fCB0aGlzLm5vdEluSW50ZXJ2YWwoJ21pbnV0ZScsIHRoaXMubWludXRlKSkpIHsKICAgICAgICByZXN1bHQucHVzaCgnbWludXRlJyk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmluVXNlLnNlY29uZCAmJiAhdGhpcy5pc0VtcHR5VmFsdWUodGhpcy5zZWNvbmRUeXBlLCB0aGlzLnNlY29uZCkgJiYgKCF0aGlzLmlzVmFsaWRWYWx1ZSh0aGlzLnNlY29uZFR5cGUsIHRoaXMuc2Vjb25kKSB8fCB0aGlzLmlzRGlzYWJsZWQoJ3NlY29uZCcsIHRoaXMuc2Vjb25kKSB8fCB0aGlzLm5vdEluSW50ZXJ2YWwoJ3NlY29uZCcsIHRoaXMuc2Vjb25kKSkpIHsKICAgICAgICByZXN1bHQucHVzaCgnc2Vjb25kJyk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmluVXNlLmFwbSAmJiAhdGhpcy5pc0VtcHR5VmFsdWUodGhpcy5hcG1UeXBlLCB0aGlzLmFwbSkgJiYgKCF0aGlzLmlzVmFsaWRWYWx1ZSh0aGlzLmFwbVR5cGUsIHRoaXMuYXBtKSB8fCB0aGlzLmlzRGlzYWJsZWQoJ2FwbScsIHRoaXMuYXBtKSkpIHsKICAgICAgICByZXN1bHQucHVzaCgnYXBtJyk7CiAgICAgIH0KCiAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQoKICAgICAgcmV0dXJuIFtdOwogICAgfSwKICAgIGhhc0ludmFsaWRJbnB1dDogZnVuY3Rpb24gaGFzSW52YWxpZElucHV0KCkgewogICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmludmFsaWRWYWx1ZXMgJiYgdGhpcy5pbnZhbGlkVmFsdWVzLmxlbmd0aCk7CiAgICB9LAogICAgYXV0b0RpcmVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uIGF1dG9EaXJlY3Rpb25FbmFibGVkKCkgewogICAgICByZXR1cm4gdGhpcy5kcm9wRGlyZWN0aW9uID09PSAnYXV0byc7CiAgICB9LAogICAgZHJvcGRvd25EaXJDbGFzczogZnVuY3Rpb24gZHJvcGRvd25EaXJDbGFzcygpIHsKICAgICAgaWYgKHRoaXMuYXV0b0RpcmVjdGlvbkVuYWJsZWQpIHsKICAgICAgICByZXR1cm4gdGhpcy5mb3JjZURyb3BPblRvcCA/ICdkcm9wLXVwJyA6ICdkcm9wLWRvd24nOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5kcm9wRGlyZWN0aW9uID09PSAndXAnID8gJ2Ryb3AtdXAnIDogJ2Ryb3AtZG93bic7CiAgICB9CiAgfSwKICB3YXRjaDogewogICAgJ29wdHMuZm9ybWF0JzogZnVuY3Rpb24gb3B0c0Zvcm1hdChuZXdWYWx1ZSkgewogICAgICB0aGlzLnJlbmRlckZvcm1hdChuZXdWYWx1ZSk7CiAgICB9LAogICAgJ29wdHMubWludXRlSW50ZXJ2YWwnOiBmdW5jdGlvbiBvcHRzTWludXRlSW50ZXJ2YWwobmV3SW50ZXZhbCkgewogICAgICB0aGlzLnJlbmRlckxpc3QoJ21pbnV0ZScsIG5ld0ludGV2YWwpOwogICAgfSwKICAgICdvcHRzLnNlY29uZEludGVydmFsJzogZnVuY3Rpb24gb3B0c1NlY29uZEludGVydmFsKG5ld0ludGV2YWwpIHsKICAgICAgdGhpcy5yZW5kZXJMaXN0KCdzZWNvbmQnLCBuZXdJbnRldmFsKTsKICAgIH0sCiAgICB2YWx1ZTogewogICAgICBkZWVwOiB0cnVlLAogICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkgewogICAgICAgIHRoaXMucmVhZFZhbHVlcygpOwogICAgICB9CiAgICB9LAogICAgZGlzcGxheVRpbWU6IGZ1bmN0aW9uIGRpc3BsYXlUaW1lKCkgewogICAgICB0aGlzLmZpbGxWYWx1ZXMoKTsKICAgIH0sCiAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQodG9EaXNhYmxlZCkgewogICAgICBpZiAodG9EaXNhYmxlZCkgewogICAgICAgIC8vIEZvcmNlIGNsb3NlIGRyb3Bkb3duIGFuZCByZXNldCBzdGF0dXMgd2hlbiBkaXNhYmxlZAogICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7CiAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7CiAgICAgICAgfQoKICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHsKICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duID0gZmFsc2U7CiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgJ2ludmFsaWRWYWx1ZXMubGVuZ3RoJzogZnVuY3Rpb24gaW52YWxpZFZhbHVlc0xlbmd0aChuZXdMZW5ndGgsIG9sZExlbmd0aCkgewogICAgICBpZiAobmV3TGVuZ3RoICYmIG5ld0xlbmd0aCA+PSAxKSB7CiAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCB0aGlzLmludmFsaWRWYWx1ZXMpOwogICAgICB9IGVsc2UgaWYgKG9sZExlbmd0aCAmJiBvbGRMZW5ndGggPj0gMSkgewogICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgW10pOwogICAgICB9CiAgICB9CiAgfSwKICBtZXRob2RzOiB7CiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUodG9rZW4sIGkpIHsKICAgICAgaWYgKCF0aGlzLmlzTnVtYmVyKGkpKSB7CiAgICAgICAgcmV0dXJuICcnOwogICAgICB9CgogICAgICBpID0gK2k7CgogICAgICBzd2l0Y2ggKHRva2VuKSB7CiAgICAgICAgY2FzZSAnSCc6CiAgICAgICAgY2FzZSAnaCc6CiAgICAgICAgY2FzZSAnayc6CiAgICAgICAgY2FzZSAnbSc6CiAgICAgICAgY2FzZSAncyc6CiAgICAgICAgICBpZiAoWydoJywgJ2snXS5pbmNsdWRlcyh0b2tlbikgJiYgaSA9PT0gMCkgewogICAgICAgICAgICByZXR1cm4gdG9rZW4gPT09ICdrJyA/ICcyNCcgOiAnMTInOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBTdHJpbmcoaSk7CgogICAgICAgIGNhc2UgJ0hIJzoKICAgICAgICBjYXNlICdtbSc6CiAgICAgICAgY2FzZSAnc3MnOgogICAgICAgIGNhc2UgJ2hoJzoKICAgICAgICBjYXNlICdrayc6CiAgICAgICAgICBpZiAoWydoaCcsICdrayddLmluY2x1ZGVzKHRva2VuKSAmJiBpID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9PT0gJ2trJyA/ICcyNCcgOiAnMTInOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBpIDwgMTAgPyAiMCIuY29uY2F0KGkpIDogU3RyaW5nKGkpOwoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuICcnOwogICAgICB9CiAgICB9LAogICAgY2hlY2tBY2NlcHRpbmdUeXBlOiBmdW5jdGlvbiBjaGVja0FjY2VwdGluZ1R5cGUodmFsaWRWYWx1ZXMsIGZvcm1hdFN0cmluZykgewogICAgICBpZiAoIXZhbGlkVmFsdWVzIHx8ICFmb3JtYXRTdHJpbmcgfHwgIWZvcm1hdFN0cmluZy5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gJyc7CiAgICAgIH0KCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsaWRWYWx1ZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICBpZiAoZm9ybWF0U3RyaW5nLmluZGV4T2YodmFsaWRWYWx1ZXNbaV0pID4gLTEpIHsKICAgICAgICAgIHJldHVybiB2YWxpZFZhbHVlc1tpXTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiAnJzsKICAgIH0sCiAgICByZW5kZXJGb3JtYXQ6IGZ1bmN0aW9uIHJlbmRlckZvcm1hdChuZXdGb3JtYXQpIHsKICAgICAgdmFyIF90aGlzNSA9IHRoaXM7CgogICAgICBuZXdGb3JtYXQgPSBuZXdGb3JtYXQgfHwgdGhpcy5vcHRzLmZvcm1hdCB8fCBERUZBVUxUX09QVElPTlMuZm9ybWF0OwogICAgICB2YXIgaG91clR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuSE9VUl9UT0tFTlMsIG5ld0Zvcm1hdCk7CiAgICAgIHZhciBtaW51dGVUeXBlID0gdGhpcy5jaGVja0FjY2VwdGluZ1R5cGUoQ09ORklHLk1JTlVURV9UT0tFTlMsIG5ld0Zvcm1hdCk7CiAgICAgIHRoaXMuc2Vjb25kVHlwZSA9IHRoaXMuY2hlY2tBY2NlcHRpbmdUeXBlKENPTkZJRy5TRUNPTkRfVE9LRU5TLCBuZXdGb3JtYXQpOwogICAgICB0aGlzLmFwbVR5cGUgPSB0aGlzLmNoZWNrQWNjZXB0aW5nVHlwZShDT05GSUcuQVBNX1RPS0VOUywgbmV3Rm9ybWF0KTsgLy8gRmFpbHNhZmUgY2hlY2tpbmcKCiAgICAgIGlmICghaG91clR5cGUgJiYgIW1pbnV0ZVR5cGUgJiYgIXRoaXMuc2Vjb25kVHlwZSAmJiAhdGhpcy5hcG1UeXBlKSB7CiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlICYmIHRoaXMuZm9ybWF0KSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCJObyB2YWxpZCB0b2tlbnMgZm91bmQgaW4geW91ciBkZWZpbmVkIFwiZm9ybWF0XCIgc3RyaW5nIFwiIi5jb25jYXQodGhpcy5mb3JtYXQsICJcIi4gRmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgXCJISDptbVwiIGZvcm1hdC4iKSk7CiAgICAgICAgfQoKICAgICAgICBob3VyVHlwZSA9ICdISCc7CiAgICAgICAgbWludXRlVHlwZSA9ICdtbSc7CiAgICAgIH0KCiAgICAgIHRoaXMuaG91clR5cGUgPSBob3VyVHlwZTsKICAgICAgdGhpcy5taW51dGVUeXBlID0gbWludXRlVHlwZTsKICAgICAgdGhpcy5ob3VyVHlwZSA/IHRoaXMucmVuZGVySG91cnNMaXN0KCkgOiB0aGlzLmhvdXJzID0gW107CiAgICAgIHRoaXMubWludXRlVHlwZSA/IHRoaXMucmVuZGVyTGlzdCgnbWludXRlJykgOiB0aGlzLm1pbnV0ZXMgPSBbXTsKICAgICAgdGhpcy5zZWNvbmRUeXBlID8gdGhpcy5yZW5kZXJMaXN0KCdzZWNvbmQnKSA6IHRoaXMuc2Vjb25kcyA9IFtdOwogICAgICB0aGlzLmFwbVR5cGUgPyB0aGlzLnJlbmRlckFwbUxpc3QoKSA6IHRoaXMuYXBtcyA9IFtdOwogICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7CiAgICAgICAgX3RoaXM1LnJlYWRWYWx1ZXMoKTsKICAgICAgfSk7CiAgICB9LAogICAgcmVuZGVySG91cnNMaXN0OiBmdW5jdGlvbiByZW5kZXJIb3Vyc0xpc3QoKSB7CiAgICAgIHZhciBob3Vyc0NvdW50ID0gdGhpcy5iYXNlT24xMkhvdXJzID8gMTIgOiAyNDsKICAgICAgdmFyIGhvdXJzID0gW107CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvdXJzQ291bnQ7IGkrKykgewogICAgICAgIGlmICh0aGlzLmhvdXJUeXBlID09PSAnaycgfHwgdGhpcy5ob3VyVHlwZSA9PT0gJ2trJykgewogICAgICAgICAgaG91cnMucHVzaCh0aGlzLmZvcm1hdFZhbHVlKHRoaXMuaG91clR5cGUsIGkgKyAxKSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGhvdXJzLnB1c2godGhpcy5mb3JtYXRWYWx1ZSh0aGlzLmhvdXJUeXBlLCBpKSk7CiAgICAgICAgfQogICAgICB9CgogICAgICB0aGlzLmhvdXJzID0gaG91cnM7CiAgICB9LAogICAgcmVuZGVyTGlzdDogZnVuY3Rpb24gcmVuZGVyTGlzdChsaXN0VHlwZSwgaW50ZXJ2YWwpIHsKICAgICAgaWYgKCF0aGlzLmlzTWludXRlT3JTZWNvbmQobGlzdFR5cGUpKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgaXNNaW51dGUgPSBsaXN0VHlwZSA9PT0gJ21pbnV0ZSc7CiAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgKGlzTWludXRlID8gdGhpcy5vcHRzLm1pbnV0ZUludGVydmFsIHx8IERFRkFVTFRfT1BUSU9OUy5taW51dGVJbnRlcnZhbCA6IHRoaXMub3B0cy5zZWNvbmRJbnRlcnZhbCB8fCBERUZBVUxUX09QVElPTlMuc2Vjb25kSW50ZXJ2YWwpOwogICAgICB2YXIgcmVzdWx0ID0gW107CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDYwOyBpICs9IGludGVydmFsKSB7CiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5mb3JtYXRWYWx1ZShpc01pbnV0ZSA/IHRoaXMubWludXRlVHlwZSA6IHRoaXMuc2Vjb25kVHlwZSwgaSkpOwogICAgICB9CgogICAgICBpc01pbnV0ZSA/IHRoaXMubWludXRlcyA9IHJlc3VsdCA6IHRoaXMuc2Vjb25kcyA9IHJlc3VsdDsKICAgIH0sCiAgICByZW5kZXJBcG1MaXN0OiBmdW5jdGlvbiByZW5kZXJBcG1MaXN0KCkgewogICAgICB0aGlzLmFwbXMgPSB0aGlzLmFwbVR5cGUgPT09ICdBJyA/IFsnQU0nLCAnUE0nXSA6IFsnYW0nLCAncG0nXTsKICAgIH0sCiAgICByZWFkVmFsdWVzOiBmdW5jdGlvbiByZWFkVmFsdWVzKCkgewogICAgICBpZiAodGhpcy51c2VTdHJpbmdWYWx1ZSkgewogICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgdGhpcy5kZWJ1Z0xvZygiUmVjZWl2ZWQgYSBzdHJpbmcgdmFsdWU6IFwiIi5jb25jYXQodGhpcy52YWx1ZSwgIlwiIikpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5yZWFkU3RyaW5nVmFsdWVzKHRoaXMudmFsdWUpOwogICAgICB9IGVsc2UgewogICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgdGhpcy5kZWJ1Z0xvZygiUmVjZWl2ZWQgYW4gb2JqZWN0IHZhbHVlOiBcIiIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUgfHwge30pLCAiXCIiKSk7CiAgICAgICAgfQoKICAgICAgICB0aGlzLnJlYWRPYmplY3RWYWx1ZXModGhpcy52YWx1ZSk7CiAgICAgIH0KICAgIH0sCiAgICByZWFkT2JqZWN0VmFsdWVzOiBmdW5jdGlvbiByZWFkT2JqZWN0VmFsdWVzKG9ialZhbHVlKSB7CiAgICAgIHZhciBfdGhpczYgPSB0aGlzOwoKICAgICAgdmFyIHRpbWVWYWx1ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqVmFsdWUgfHwge30pKTsKICAgICAgdmFyIHZhbHVlcyA9IE9iamVjdC5rZXlzKHRpbWVWYWx1ZSk7IC8vIEZhaWxzYWZlIGZvciBlbXB0eSBgdi1tb2RlbGAgb2JqZWN0CgogICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgewogICAgICAgIHRoaXMuYWRkRmFsbGJhY2tWYWx1ZXMoKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIENPTkZJRy5CQVNJQ19UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7CiAgICAgICAgdmFyIHRva2VuID0gX3RoaXM2LmdldFRva2VuQnlUeXBlKHR5cGUpOwoKICAgICAgICBpZiAodmFsdWVzLmluZGV4T2YodG9rZW4pID4gLTEpIHsKICAgICAgICAgIHZhciBzYW5pdGl6ZWRWYWx1ZSA9IF90aGlzNi5zYW5pdGl6ZWRWYWx1ZSh0b2tlbiwgdGltZVZhbHVlW3Rva2VuXSk7CgogICAgICAgICAgX3RoaXM2W3R5cGVdID0gc2FuaXRpemVkVmFsdWU7CiAgICAgICAgICB0aW1lVmFsdWVbdG9rZW5dID0gc2FuaXRpemVkVmFsdWU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIF90aGlzNlt0eXBlXSA9ICcnOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHRoaXMudGltZVZhbHVlID0gdGltZVZhbHVlOwogICAgfSwKICAgIGdldE1hdGNoQWxsQnlSZWdleDogZnVuY3Rpb24gZ2V0TWF0Y2hBbGxCeVJlZ2V4KHRlc3RTdHJpbmcsIHJlZ2V4U3RyaW5nKSB7CiAgICAgIHZhciBzdHIgPSAncG9seWZpbGxUZXN0JzsKICAgICAgdmFyIG5lZWRzUG9seWZpbGwgPSBCb29sZWFuKCFzdHIubWF0Y2hBbGwgfHwgdHlwZW9mIHN0ci5tYXRjaEFsbCAhPT0gJ2Z1bmN0aW9uJyk7CiAgICAgIHJldHVybiBuZWVkc1BvbHlmaWxsID8gdGhpcy5wb2x5ZmlsbE1hdGNoQWxsKHRlc3RTdHJpbmcsIHJlZ2V4U3RyaW5nKSA6IHRlc3RTdHJpbmcubWF0Y2hBbGwobmV3IFJlZ0V4cChyZWdleFN0cmluZywgJ2cnKSk7CiAgICB9LAogICAgcmVhZFN0cmluZ1ZhbHVlczogZnVuY3Rpb24gcmVhZFN0cmluZ1ZhbHVlcyhzdHJpbmdWYWx1ZSkgewogICAgICB2YXIgX3RoaXM3ID0gdGhpczsKCiAgICAgIC8vIEZhaWxzYWZlIGZvciBlbXB0eSBgdi1tb2RlbGAgc3RyaW5nCiAgICAgIGlmICghc3RyaW5nVmFsdWUgfHwgIXN0cmluZ1ZhbHVlLmxlbmd0aCkgewogICAgICAgIHRoaXMuYWRkRmFsbGJhY2tWYWx1ZXMoKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBmb3JtYXRTdHJpbmcgPSBTdHJpbmcodGhpcy5mb3JtYXRTdHJpbmcpOwogICAgICB2YXIgdG9rZW5zUmVneFN0ciA9ICIoIi5jb25jYXQodGhpcy50b2tlblJlZ2V4QmFzZSwgIikrPyIpOwogICAgICB2YXIgb3RoZXJzUmVneFN0ciA9ICJbXigiLmNvbmNhdCh0aGlzLnRva2VuUmVnZXhCYXNlLCAiKV0rIik7CiAgICAgIHZhciB0b2tlbnNNYXRjaEFsbCA9IHRoaXMuZ2V0TWF0Y2hBbGxCeVJlZ2V4KGZvcm1hdFN0cmluZywgdG9rZW5zUmVneFN0cik7CiAgICAgIHZhciBvdGhlcnNNYXRjaEFsbCA9IHRoaXMuZ2V0TWF0Y2hBbGxCeVJlZ2V4KGZvcm1hdFN0cmluZywgb3RoZXJzUmVneFN0cik7CiAgICAgIHZhciBjaHVua3MgPSBbXTsKICAgICAgdmFyIHRva2VuQ2h1bmtzID0gW107CgogICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRva2Vuc01hdGNoQWxsKSwKICAgICAgICAgIF9zdGVwMjsKCiAgICAgIHRyeSB7CiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHsKICAgICAgICAgIHZhciB0a01hdGNoID0gX3N0ZXAyLnZhbHVlOwogICAgICAgICAgdmFyIHRva2VuTWF0Y2hJdGVtID0gewogICAgICAgICAgICBpbmRleDogdGtNYXRjaC5pbmRleCwKICAgICAgICAgICAgdG9rZW46IHRrTWF0Y2hbMF0sCiAgICAgICAgICAgIGlzVmFsdWVUb2tlbjogdHJ1ZQogICAgICAgICAgfTsKICAgICAgICAgIGNodW5rcy5wdXNoKHRva2VuTWF0Y2hJdGVtKTsKICAgICAgICAgIHRva2VuQ2h1bmtzLnB1c2godG9rZW5NYXRjaEl0ZW0pOwogICAgICAgIH0KICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7CiAgICAgIH0gZmluYWxseSB7CiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7CiAgICAgIH0KCiAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3RoZXJzTWF0Y2hBbGwpLAogICAgICAgICAgX3N0ZXAzOwoKICAgICAgdHJ5IHsKICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykgewogICAgICAgICAgdmFyIG90TWF0Y2ggPSBfc3RlcDMudmFsdWU7CiAgICAgICAgICBjaHVua3MucHVzaCh7CiAgICAgICAgICAgIGluZGV4OiBvdE1hdGNoLmluZGV4LAogICAgICAgICAgICB0b2tlbjogb3RNYXRjaFswXQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTsKICAgICAgfSBmaW5hbGx5IHsKICAgICAgICBfaXRlcmF0b3IzLmYoKTsKICAgICAgfQoKICAgICAgY2h1bmtzLnNvcnQoZnVuY3Rpb24gKGwsIHIpIHsKICAgICAgICByZXR1cm4gbC5pbmRleCA8IHIuaW5kZXggPyAtMSA6IDE7CiAgICAgIH0pOwogICAgICB2YXIgcmVnZXhDb21ibyA9ICcnOwogICAgICBjaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHsKICAgICAgICBpZiAoY2h1bmsuaXNWYWx1ZVRva2VuKSB7CiAgICAgICAgICB2YXIgdG9rZW5SZWdleCA9IF90aGlzNy5nZXRUb2tlblJlZ2V4KGNodW5rLnRva2VuKSB8fCAnJzsKICAgICAgICAgIHJlZ2V4Q29tYm8gKz0gdG9rZW5SZWdleDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIHNhZmVDaGFycyA9IGNodW5rLnRva2VuLnJlcGxhY2UoL1xcezB9KFwqfFw/fFwufFwrKS9nLCAnXFwkMScpOwogICAgICAgICAgcmVnZXhDb21ibyArPSAiKD86Ii5jb25jYXQoc2FmZUNoYXJzLCAiKSIpOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHZhciBjb21ib1JlZyA9IG5ldyBSZWdFeHAocmVnZXhDb21ibyk7IC8vIERvIHRlc3QgYmVmb3JlIG1hdGNoCgogICAgICBpZiAoY29tYm9SZWcudGVzdChzdHJpbmdWYWx1ZSkpIHsKICAgICAgICB2YXIgbWF0Y2hSZXN1bHRzID0gc3RyaW5nVmFsdWUubWF0Y2gobmV3IFJlZ0V4cChyZWdleENvbWJvKSk7CiAgICAgICAgdmFyIHZhbHVlUmVzdWx0cyA9IG1hdGNoUmVzdWx0cy5zbGljZSgxLCB0b2tlbkNodW5rcy5sZW5ndGggKyAxKTsKICAgICAgICB2YXIgdGltZVZhbHVlID0ge307CiAgICAgICAgdmFsdWVSZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCB2ckluZGV4KSB7CiAgICAgICAgICBpZiAodG9rZW5DaHVua3NbdnJJbmRleF0pIHsKICAgICAgICAgICAgdmFyIHRhcmdldFRva2VuID0gdG9rZW5DaHVua3NbdnJJbmRleF0udG9rZW47CiAgICAgICAgICAgIHRpbWVWYWx1ZVt0YXJnZXRUb2tlbl0gPSBfdGhpczcuc2V0VmFsdWVGcm9tU3RyaW5nKHZhbHVlLCB0YXJnZXRUb2tlbik7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgdGhpcy50aW1lVmFsdWUgPSB0aW1lVmFsdWU7CgogICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgdmFyIHRva2VuQ2h1bmtzRm9yTG9nID0gdG9rZW5DaHVua3MubWFwKGZ1bmN0aW9uICh0Q2h1bmspIHsKICAgICAgICAgICAgcmV0dXJuIHRDaHVuayAmJiB0Q2h1bmsudG9rZW47CiAgICAgICAgICB9KTsKICAgICAgICAgIHRoaXMuZGVidWdMb2coIlN1Y2Nlc3NmdWxseSBwYXJzZWQgdmFsdWVzICIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHZhbHVlUmVzdWx0cyksICJcbmZvciAiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkodG9rZW5DaHVua3NGb3JMb2cpLCAiXG5pbiBmb3JtYXQgcGF0dGVybiAnIikuY29uY2F0KHRoaXMuZm9ybWF0U3RyaW5nLCAiJyIpKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCJUaGUgaW5wdXQgc3RyaW5nIGluIFwidi1tb2RlbFwiIGRvZXMgTk9UIG1hdGNoIHRoZSBcImZvcm1hdFwiIHBhdHRlcm5cbmZvcm1hdDogIi5jb25jYXQodGhpcy5mb3JtYXRTdHJpbmcsICJcbnYtbW9kZWw6ICIpLmNvbmNhdChzdHJpbmdWYWx1ZSkpOwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIHBvbHlmaWxsTWF0Y2hBbGw6IGZ1bmN0aW9uIHBvbHlmaWxsTWF0Y2hBbGwodGFyZ2V0U3RyaW5nLCByZWd4U3RyKSB7CiAgICAgIHZhciBtYXRjaGVzTGlzdCA9IHRhcmdldFN0cmluZy5tYXRjaChuZXcgUmVnRXhwKHJlZ3hTdHIsICdnJykpOwogICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgIHZhciBpbmRpY2VzUmVnID0gW107CgogICAgICBpZiAobWF0Y2hlc0xpc3QgJiYgbWF0Y2hlc0xpc3QubGVuZ3RoKSB7CiAgICAgICAgbWF0Y2hlc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hlZEl0ZW0pIHsKICAgICAgICAgIHZhciBleGlzdEluZGV4ID0gaW5kaWNlc1JlZy5maW5kSW5kZXgoZnVuY3Rpb24gKGlkeEl0ZW0pIHsKICAgICAgICAgICAgcmV0dXJuIGlkeEl0ZW0uc3RyID09PSBtYXRjaGVkSXRlbTsKICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIGluZGV4OwoKICAgICAgICAgIGlmIChleGlzdEluZGV4ID49IDApIHsKICAgICAgICAgICAgaWYgKGluZGljZXNSZWdbZXhpc3RJbmRleF0gJiYgaW5kaWNlc1JlZ1tleGlzdEluZGV4XS5yZWdleCkgewogICAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc1JlZ1tleGlzdEluZGV4XS5yZWdleC5leGVjKHRhcmdldFN0cmluZykuaW5kZXg7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBpdGVtSW5kaWNlc1JlZ2V4ID0gbmV3IFJlZ0V4cChtYXRjaGVkSXRlbSwgJ2cnKTsKICAgICAgICAgICAgaW5kZXggPSBpdGVtSW5kaWNlc1JlZ2V4LmV4ZWModGFyZ2V0U3RyaW5nKS5pbmRleDsKICAgICAgICAgICAgaW5kaWNlc1JlZy5wdXNoKHsKICAgICAgICAgICAgICBzdHI6IFN0cmluZyhtYXRjaGVkSXRlbSksCiAgICAgICAgICAgICAgcmVnZXg6IGl0ZW1JbmRpY2VzUmVnZXgKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CgogICAgICAgICAgcmVzdWx0LnB1c2goewogICAgICAgICAgICAwOiBTdHJpbmcobWF0Y2hlZEl0ZW0pLAogICAgICAgICAgICBpbmRleDogaW5kZXgKICAgICAgICAgIH0pOwogICAgICAgIH0pOwogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfSwKICAgIGFkZEZhbGxiYWNrVmFsdWVzOiBmdW5jdGlvbiBhZGRGYWxsYmFja1ZhbHVlcygpIHsKICAgICAgdmFyIF90aGlzOCA9IHRoaXM7CgogICAgICB2YXIgdGltZVZhbHVlID0ge307CiAgICAgIHRoaXMuaW5Vc2UudHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkgewogICAgICAgIHRpbWVWYWx1ZVtfdGhpczguZ2V0VG9rZW5CeVR5cGUodHlwZSldID0gJyc7CiAgICAgIH0pOwogICAgICB0aGlzLnRpbWVWYWx1ZSA9IHRpbWVWYWx1ZTsKICAgIH0sCiAgICBzZXRWYWx1ZUZyb21TdHJpbmc6IGZ1bmN0aW9uIHNldFZhbHVlRnJvbVN0cmluZyhwYXJzZWRWYWx1ZSwgdG9rZW4pIHsKICAgICAgaWYgKCF0b2tlbiB8fCAhcGFyc2VkVmFsdWUpIHsKICAgICAgICByZXR1cm4gJyc7CiAgICAgIH0KCiAgICAgIHZhciB0b2tlblR5cGUgPSB0aGlzLmdldFRva2VuVHlwZSh0b2tlbik7CgogICAgICBpZiAoIXRva2VuVHlwZSB8fCAhdG9rZW5UeXBlLmxlbmd0aCkgewogICAgICAgIHJldHVybiAnJzsKICAgICAgfQoKICAgICAgdmFyIHN0ZFZhbHVlID0gcGFyc2VkVmFsdWUgIT09IHRoaXMuZ2V0VG9rZW5CeVR5cGUodG9rZW5UeXBlKSA/IHBhcnNlZFZhbHVlIDogJyc7CiAgICAgIHRoaXNbdG9rZW5UeXBlXSA9IHN0ZFZhbHVlOwogICAgICByZXR1cm4gc3RkVmFsdWU7CiAgICB9LAogICAgZmlsbFZhbHVlczogZnVuY3Rpb24gZmlsbFZhbHVlcyhmb3JjZUVtaXQpIHsKICAgICAgdmFyIF90aGlzOSA9IHRoaXM7CgogICAgICB2YXIgZnVsbFZhbHVlcyA9IHt9OwogICAgICB2YXIgYmFzZUhvdXIgPSB0aGlzLmhvdXI7CiAgICAgIHZhciBiYXNlSG91clR5cGUgPSB0aGlzLmhvdXJUeXBlOwogICAgICB2YXIgYXBtVmFsdWU7IC8vIEhvdXIgdHlwZSBvciBob3VyIHZhbHVlIGlzIE5PVCBzZXQgaW4gdGhlICJmb3JtYXQiIHN0cmluZwoKICAgICAgaWYgKCFiYXNlSG91clR5cGUgfHwgIXRoaXMuaXNOdW1iZXIoYmFzZUhvdXIpKSB7CiAgICAgICAgQ09ORklHLkhPVVJfVE9LRU5TLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7CiAgICAgICAgICByZXR1cm4gZnVsbFZhbHVlc1t0b2tlbl0gPSAnJzsKICAgICAgICB9KTsKICAgICAgICBhcG1WYWx1ZSA9IHRoaXMubG93ZXJDYXNlZEFwbSh0aGlzLmFwbSB8fCAnJyk7CiAgICAgICAgZnVsbFZhbHVlcy5hID0gYXBtVmFsdWU7CiAgICAgICAgZnVsbFZhbHVlcy5BID0gYXBtVmFsdWUudG9VcHBlckNhc2UoKTsgLy8gQm90aCBIb3VyIHR5cGUgYW5kIHZhbHVlIGFyZSBzZXQKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgaG91clZhbHVlID0gK2Jhc2VIb3VyOwoKICAgICAgICB2YXIgX2FwbVZhbHVlID0gdGhpcy5iYXNlT24xMkhvdXJzICYmIHRoaXMuYXBtID8gdGhpcy5sb3dlckNhc2VkQXBtKHRoaXMuYXBtKSA6IGZhbHNlOwoKICAgICAgICBDT05GSUcuSE9VUl9UT0tFTlMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHsKICAgICAgICAgIGlmICh0b2tlbiA9PT0gYmFzZUhvdXJUeXBlKSB7CiAgICAgICAgICAgIGZ1bGxWYWx1ZXNbdG9rZW5dID0gYmFzZUhvdXI7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgdmFsdWU7CiAgICAgICAgICB2YXIgYXBtOwoKICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHsKICAgICAgICAgICAgY2FzZSAnSCc6CiAgICAgICAgICAgIGNhc2UgJ0hIJzoKICAgICAgICAgICAgY2FzZSAnayc6CiAgICAgICAgICAgIGNhc2UgJ2trJzoKICAgICAgICAgICAgICBpZiAoX3RoaXM5LmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgIGlmIChfYXBtVmFsdWUgPT09ICdwbScpIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgPCAxMiA/IGhvdXJWYWx1ZSArIDEyIDogaG91clZhbHVlOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbJ2snLCAna2snXS5pbmNsdWRlcyh0b2tlbikpIHsKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgPT09IDEyID8gMjQgOiBob3VyVmFsdWU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSAlIDEyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAoWydrJywgJ2trJ10uaW5jbHVkZXModG9rZW4pKSB7CiAgICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlID09PSAwID8gMjQgOiBob3VyVmFsdWU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSAlIDI0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgZnVsbFZhbHVlc1t0b2tlbl0gPSBfdGhpczkuZm9ybWF0VmFsdWUodG9rZW4sIHZhbHVlKTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgJ2gnOgogICAgICAgICAgICBjYXNlICdoaCc6CiAgICAgICAgICAgICAgLy8gaCA8LT4gaGgKICAgICAgICAgICAgICBpZiAoX3RoaXM5LmJhc2VPbjEySG91cnMpIHsKICAgICAgICAgICAgICAgIHZhbHVlID0gaG91clZhbHVlOwogICAgICAgICAgICAgICAgYXBtID0gX2FwbVZhbHVlIHx8ICcnOyAvLyBSZWFkIGZyb20gb3RoZXIgaG91ciBmb3JtYXRzCiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmIChob3VyVmFsdWUgPiAxMSAmJiBob3VyVmFsdWUgPCAyNCkgewogICAgICAgICAgICAgICAgICBhcG0gPSAncG0nOwogICAgICAgICAgICAgICAgICB2YWx1ZSA9IGhvdXJWYWx1ZSA9PT0gMTIgPyAxMiA6IGhvdXJWYWx1ZSAlIDEyOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgYXBtID0gJ2FtJzsKICAgICAgICAgICAgICAgICAgdmFsdWUgPSBob3VyVmFsdWUgJSAxMiA9PT0gMCA/IDEyIDogaG91clZhbHVlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgZnVsbFZhbHVlc1t0b2tlbl0gPSBfdGhpczkuZm9ybWF0VmFsdWUodG9rZW4sIHZhbHVlKTsKICAgICAgICAgICAgICBmdWxsVmFsdWVzLmEgPSBhcG07CiAgICAgICAgICAgICAgZnVsbFZhbHVlcy5BID0gYXBtLnRvVXBwZXJDYXNlKCk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIGZ1bGxWYWx1ZXMubSA9IHRoaXMuZm9ybWF0VmFsdWUoJ20nLCB0aGlzLm1pbnV0ZSk7CiAgICAgIGZ1bGxWYWx1ZXMubW0gPSB0aGlzLmZvcm1hdFZhbHVlKCdtbScsIHRoaXMubWludXRlKTsKICAgICAgZnVsbFZhbHVlcy5zID0gdGhpcy5mb3JtYXRWYWx1ZSgncycsIHRoaXMuc2Vjb25kKTsKICAgICAgZnVsbFZhbHVlcy5zcyA9IHRoaXMuZm9ybWF0VmFsdWUoJ3NzJywgdGhpcy5zZWNvbmQpOwogICAgICB0aGlzLmZ1bGxWYWx1ZXMgPSBmdWxsVmFsdWVzOyAvLyBPbiBsYXp5IG1vZGUsIGVtaXQgYGlucHV0YCBhbmQgYGNoYW5nZWAgZXZlbnRzIG9ubHkgd2hlbjoKICAgICAgLy8gLSBUaGUgdXNlciBwaWNrIGEgbmV3IHZhbHVlIGFuZCB0aGVuIGNsb3NlIHRoZSBkcm9wZG93bgogICAgICAvLyAtIFRoZSB1c2VyIGNsaWNrIHRoZSAoIngiKSBjbGVhciBidXR0b24KCiAgICAgIGlmICghdGhpcy5sYXp5IHx8IGZvcmNlRW1pdCkgewogICAgICAgIHRoaXMuZW1pdFRpbWVWYWx1ZSgpOwogICAgICB9CgogICAgICBpZiAodGhpcy5jbG9zZU9uQ29tcGxldGUgJiYgdGhpcy5hbGxWYWx1ZVNlbGVjdGVkICYmIHRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgdGhpcy50b2dnbGVBY3RpdmUoKTsKICAgICAgfQogICAgfSwKICAgIGdldEZ1bGxEYXRhOiBmdW5jdGlvbiBnZXRGdWxsRGF0YSgpIHsKICAgICAgaWYgKCF0aGlzLmZ1bGxWYWx1ZXMpIHsKICAgICAgICB0aGlzLmZpbGxWYWx1ZXMoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICBkYXRhOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZnVsbFZhbHVlcykpLAogICAgICAgIGRpc3BsYXlUaW1lOiB0aGlzLmlucHV0SXNFbXB0eSA/ICcnIDogU3RyaW5nKHRoaXMuZGlzcGxheVRpbWUpCiAgICAgIH07CiAgICB9LAogICAgZW1pdFRpbWVWYWx1ZTogZnVuY3Rpb24gZW1pdFRpbWVWYWx1ZSgpIHsKICAgICAgaWYgKHRoaXMubGF6eSAmJiB0aGlzLmJha0Rpc3BsYXlUaW1lID09PSB0aGlzLmRpc3BsYXlUaW1lKSB7CiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdUaGUgdmFsdWUgZG9lcyBub3QgY2hhbmdlIG9uIGBsYXp5YCBtb2RlLiBTa2lwIHRoZSBlbWl0dGluZyBgaW5wdXRgIGFuZCBgY2hhbmdlYCBldmVudC4nKTsKICAgICAgICB9CgogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGZ1bGxEYXRhID0gdGhpcy5nZXRGdWxsRGF0YSgpOwoKICAgICAgaWYgKHRoaXMudXNlU3RyaW5nVmFsdWUpIHsKICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGZ1bGxEYXRhLmRpc3BsYXlUaW1lKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgZnVsbFZhbHVlcyA9IGZ1bGxEYXRhLmRhdGE7CiAgICAgICAgdmFyIHRva2Vuc0luVXNlID0gdGhpcy5pblVzZS50b2tlbnMgfHwgW107CiAgICAgICAgdmFyIHRpbWVWYWx1ZSA9IHt9OwogICAgICAgIHRva2Vuc0luVXNlLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7CiAgICAgICAgICB0aW1lVmFsdWVbdG9rZW5dID0gZnVsbFZhbHVlc1t0b2tlbl0gfHwgJyc7CiAgICAgICAgfSk7CiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRpbWVWYWx1ZSkpKTsKICAgICAgfQoKICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZnVsbERhdGEpOwogICAgfSwKICAgIHRyYW5zbGF0ZTEyaFJhbmdlOiBmdW5jdGlvbiB0cmFuc2xhdGUxMmhSYW5nZSh2YWx1ZSkgewogICAgICB2YXIgdmFsdWVUID0gdGhpcy5tYXRjaDEyaFJhbmdlKHZhbHVlKTsKCiAgICAgIGlmICgrdmFsdWVUWzFdID09PSAxMikgewogICAgICAgIHJldHVybiArdmFsdWVUWzFdICsgKHZhbHVlVFsyXS50b0xvd2VyQ2FzZSgpID09PSAncCcgPyAwIDogMTIpOwogICAgICB9CgogICAgICByZXR1cm4gK3ZhbHVlVFsxXSArICh2YWx1ZVRbMl0udG9Mb3dlckNhc2UoKSA9PT0gJ3AnID8gMTIgOiAwKTsKICAgIH0sCiAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbiBpc0Rpc2FibGVkKHR5cGUsIHZhbHVlKSB7CiAgICAgIGlmICghdGhpcy5pc0Jhc2ljVHlwZSh0eXBlKSB8fCAhdGhpcy5pblVzZVt0eXBlXSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CgogICAgICBzd2l0Y2ggKHR5cGUpIHsKICAgICAgICBjYXNlICdob3VyJzoKICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlzYWJsZWRIb3VyKHZhbHVlKTsKCiAgICAgICAgY2FzZSAnbWludXRlJzoKICAgICAgICBjYXNlICdzZWNvbmQnOgogICAgICAgICAgaWYgKCF0aGlzWyIiLmNvbmNhdCh0eXBlLCAiUmFuZ2VMaXN0IildKSB7CiAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgIH0KCiAgICAgICAgICByZXR1cm4gIXRoaXNbIiIuY29uY2F0KHR5cGUsICJSYW5nZUxpc3QiKV0uaW5jbHVkZXModmFsdWUpOwoKICAgICAgICBjYXNlICdhcG0nOgogICAgICAgICAgaWYgKCF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiAhdGhpcy5oYXNbdGhpcy5sb3dlckNhc2VkQXBtKHZhbHVlKV07CgogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfSwKICAgIGlzRGlzYWJsZWRIb3VyOiBmdW5jdGlvbiBpc0Rpc2FibGVkSG91cih2YWx1ZSkgewogICAgICBpZiAoIXRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuYmFzZU9uMTJIb3VycykgewogICAgICAgIGlmICghdGhpcy5hcG0gfHwgIXRoaXMuYXBtLmxlbmd0aCkgewogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmFwbS50b0xvd2VyQ2FzZSgpID09PSAnYW0nID8gJ2EnIDogJ3AnOwogICAgICAgICAgcmV0dXJuICF0aGlzLnJlc3RyaWN0ZWRIb3VyUmFuZ2UuaW5jbHVkZXMoIiIuY29uY2F0KCt2YWx1ZSkuY29uY2F0KHRva2VuKSk7CiAgICAgICAgfQogICAgICB9IC8vIEZhbGxiYWNrIGZvciAnSEgnIGFuZCAnSCBob3VyIGZvcm1hdCB3aXRoIGEgYGhvdXItcmFuZ2VgIGluIGEgMTItaG91ciBmb3JtCgoKICAgICAgaWYgKCh0aGlzLmhvdXJUeXBlID09PSAnSEgnIHx8IHRoaXMuaG91clR5cGUgPT09ICdIJykgJiYgK3ZhbHVlID09PSAwICYmIHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZS5pbmNsdWRlcygyNCkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiAhdGhpcy5yZXN0cmljdGVkSG91clJhbmdlLmluY2x1ZGVzKCt2YWx1ZSk7CiAgICB9LAogICAgbm90SW5JbnRlcnZhbDogZnVuY3Rpb24gbm90SW5JbnRlcnZhbChzZWN0aW9uLCB2YWx1ZSkgewogICAgICBpZiAoIXNlY3Rpb24gfHwgIXRoaXMuaXNNaW51dGVPclNlY29uZChzZWN0aW9uKSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKHRoaXMub3B0c1siIi5jb25jYXQoc2VjdGlvbiwgIkludGVydmFsIildID09PSAxKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICByZXR1cm4gK3ZhbHVlICUgdGhpcy5vcHRzWyIiLmNvbmNhdChzZWN0aW9uLCAiSW50ZXJ2YWwiKV0gIT09IDA7CiAgICB9LAogICAgcmVuZGVyUmFuZ2VMaXN0OiBmdW5jdGlvbiByZW5kZXJSYW5nZUxpc3QocmF3UmFuZ2UsIHNlY3Rpb24pIHsKICAgICAgdmFyIF90aGlzMTAgPSB0aGlzOwoKICAgICAgaWYgKCFyYXdSYW5nZSB8fCAhc2VjdGlvbiB8fCAhdGhpcy5pc01pbnV0ZU9yU2Vjb25kKHNlY3Rpb24pKSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CgogICAgICB2YXIgcmFuZ2UgPSBbXTsKICAgICAgdmFyIGZvcm1hdGVkVmFsdWU7CiAgICAgIHJhd1JhbmdlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHsKICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICYmIF90aGlzMTAuZGVidWdNb2RlKSB7CiAgICAgICAgICAgIF90aGlzMTAuZGVidWdMb2coIk5lc3RlZCBhcnJheSB3aXRoaW4gXCIiLmNvbmNhdChzZWN0aW9uLCAiLXJhbmdlXCIgbXVzdCBjb250YWluIG5vIG1vcmUgdGhhbiB0d28gaXRlbXMuIE9ubHkgdGhlIGZpcnN0IHR3byBpdGVtcyBvZiAiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkodmFsdWUpLCAiIHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50LiIpKTsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgc3RhcnQgPSB2YWx1ZVswXTsKICAgICAgICAgIHZhciBlbmQgPSB2YWx1ZVsxXSB8fCB2YWx1ZVswXTsKCiAgICAgICAgICBmb3IgKHZhciBpID0gK3N0YXJ0OyBpIDw9ICtlbmQ7IGkrKykgewogICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+IDU5KSB7CiAgICAgICAgICAgICAgY29udGludWU7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGZvcm1hdGVkVmFsdWUgPSBfdGhpczEwLmZvcm1hdFZhbHVlKF90aGlzMTAuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbiksIGkpOwoKICAgICAgICAgICAgaWYgKCFyYW5nZS5pbmNsdWRlcyhmb3JtYXRlZFZhbHVlKSkgewogICAgICAgICAgICAgIHJhbmdlLnB1c2goZm9ybWF0ZWRWYWx1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKCt2YWx1ZSA8IDAgfHwgK3ZhbHVlID4gNTkpIHsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQoKICAgICAgICAgIGZvcm1hdGVkVmFsdWUgPSBfdGhpczEwLmZvcm1hdFZhbHVlKF90aGlzMTAuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbiksIHZhbHVlKTsKCiAgICAgICAgICBpZiAoIXJhbmdlLmluY2x1ZGVzKGZvcm1hdGVkVmFsdWUpKSB7CiAgICAgICAgICAgIHJhbmdlLnB1c2goZm9ybWF0ZWRWYWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KTsKICAgICAgcmFuZ2Uuc29ydChmdW5jdGlvbiAobCwgcikgewogICAgICAgIHJldHVybiBsIC0gcjsKICAgICAgfSk7IC8vIERlYnVnIE1vZGUKCiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgIHZhciBmdWxsTGlzdCA9IChzZWN0aW9uID09PSAnbWludXRlJyA/IHRoaXMubWludXRlcyA6IHRoaXMuc2Vjb25kcykgfHwgW107CiAgICAgICAgdmFyIHZhbGlkSXRlbXMgPSBmdWxsTGlzdC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgIHJldHVybiByYW5nZS5pbmNsdWRlcyhpdGVtKTsKICAgICAgICB9KTsKCiAgICAgICAgaWYgKCF2YWxpZEl0ZW1zIHx8ICF2YWxpZEl0ZW1zLmxlbmd0aCkgewogICAgICAgICAgaWYgKHNlY3Rpb24gPT09ICdtaW51dGUnKSB7CiAgICAgICAgICAgIHRoaXMuZGVidWdMb2coIlRoZSBtaW51dGUgbGlzdCBpcyBlbXB0eSBkdWUgdG8gdGhlIFwibWludXRlLXJhbmdlXCIgY29uZmlnXG5taW51dGUtcmFuZ2U6ICIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMubWludXRlUmFuZ2UpLCAiXG5taW51dGUtaW50ZXJ2YWw6ICIpLmNvbmNhdCh0aGlzLm9wdHMubWludXRlSW50ZXJ2YWwpKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMuZGVidWdMb2coIlRoZSBzZWNvbmQgbGlzdCBpcyBlbXB0eSBkdWUgdG8gdGhlIFwic2Vjb25kLXJhbmdlXCIgY29uZmlnXG5zZWNvbmQtcmFuZ2U6ICIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMuc2Vjb25kUmFuZ2UpLCAiXG5zZWNvbmQtaW50ZXJ2YWw6ICIpLmNvbmNhdCh0aGlzLm9wdHMuc2Vjb25kSW50ZXJ2YWwpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiByYW5nZTsKICAgIH0sCiAgICBmb3JjZUFwbVNlbGVjdGlvbjogZnVuY3Rpb24gZm9yY2VBcG1TZWxlY3Rpb24oKSB7CiAgICAgIGlmICh0aGlzLm1hbnVhbElucHV0KSB7CiAgICAgICAgLy8gU2tpcCB0aGlzIHRvIGFsbG93IHVzZXJzIHRvIHBhc3RlIGEgc3RyaW5nIHZhbHVlIGZyb20gdGhlIGNsaXBib2FyZCBpbiBNYW51YWwgSW5wdXQgbW9kZQogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuYXBtVHlwZSAmJiAhdGhpcy5hcG0pIHsKICAgICAgICBpZiAodGhpcy5oYXMuYW0gfHwgdGhpcy5oYXMucG0pIHsKICAgICAgICAgIHRoaXMuZG9DbGVhckFwbUNoZWNraW5nID0gdHJ1ZTsKICAgICAgICAgIHZhciBhcG1WYWx1ZSA9IHRoaXMuaGFzLmFtID8gJ2FtJyA6ICdwbSc7CiAgICAgICAgICB0aGlzLmFwbSA9IHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gYXBtVmFsdWUudG9VcHBlckNhc2UoKSA6IGFwbVZhbHVlOwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIGVtcHR5QXBtU2VsZWN0aW9uOiBmdW5jdGlvbiBlbXB0eUFwbVNlbGVjdGlvbigpIHsKICAgICAgaWYgKHRoaXMuZG9DbGVhckFwbUNoZWNraW5nICYmIHRoaXMuaG91ciA9PT0gJycgJiYgdGhpcy5taW51dGUgPT09ICcnICYmIHRoaXMuc2Vjb25kID09PSAnJykgewogICAgICAgIHRoaXMuYXBtID0gJyc7CiAgICAgIH0KCiAgICAgIHRoaXMuZG9DbGVhckFwbUNoZWNraW5nID0gZmFsc2U7CiAgICB9LAogICAgYXBtRGlzcGxheVRleHQ6IGZ1bmN0aW9uIGFwbURpc3BsYXlUZXh0KGFwbVZhbHVlKSB7CiAgICAgIGlmICh0aGlzLmFtVGV4dCAmJiB0aGlzLmxvd2VyQ2FzZWRBcG0oYXBtVmFsdWUpID09PSAnYW0nKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuYW1UZXh0OwogICAgICB9CgogICAgICBpZiAodGhpcy5wbVRleHQgJiYgdGhpcy5sb3dlckNhc2VkQXBtKGFwbVZhbHVlKSA9PT0gJ3BtJykgewogICAgICAgIHJldHVybiB0aGlzLnBtVGV4dDsKICAgICAgfQoKICAgICAgcmV0dXJuIGFwbVZhbHVlOwogICAgfSwKICAgIHRvZ2dsZUFjdGl2ZTogZnVuY3Rpb24gdG9nZ2xlQWN0aXZlKCkgewogICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7CgogICAgICBpZiAodGhpcy5kaXNhYmxlZCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5pc0FjdGl2ZSA9ICF0aGlzLmlzQWN0aXZlOwoKICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHsKICAgICAgICB0aGlzLmlzRm9jdXNpbmcgPSB0cnVlOwoKICAgICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCkgewogICAgICAgICAgdGhpcy4kZW1pdCgnZm9jdXMnKTsKICAgICAgICB9CgogICAgICAgIGlmICghdGhpcy5vcHRzLmhpZGVEcm9wZG93bikgewogICAgICAgICAgdGhpcy5zZXREcm9wZG93blN0YXRlKHRydWUpOwogICAgICAgIH0gLy8gUmVjb3JkIHRvIGNoZWNrIGlmIHZhbHVlIGRpZCBjaGFuZ2UgaW4gdGhlIGxhdGVyIHBoYXNlCgoKICAgICAgICBpZiAodGhpcy5sYXp5KSB7CiAgICAgICAgICB0aGlzLmJha0Rpc3BsYXlUaW1lID0gU3RyaW5nKHRoaXMuZGlzcGxheVRpbWUgfHwgJycpOwogICAgICAgIH0KCiAgICAgICAgaWYgKHRoaXMubWFudWFsSW5wdXQgJiYgIXRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGlmIChfdGhpczExLiRyZWZzLmlucHV0ICYmIF90aGlzMTEuJHJlZnMuaW5wdXQuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgX3RoaXMxMS4kcmVmcy5pbnB1dC5zZWxlY3Rpb25FbmQgPT09IF90aGlzMTEuZGlzcGxheVRpbWUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBmaXJzdCBzbG90IGluc3RlYWQgb2YgdGhlIHdob2xlIHZhbHVlIHN0cmluZyB3aGVuIHRhYmJlZCBpbgogICAgICAgICAgICAgIF90aGlzMTEuc2VsZWN0Rmlyc3RTbG90KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAodGhpcy5zaG93RHJvcGRvd24pIHsKICAgICAgICAgIHRoaXMuc2V0RHJvcGRvd25TdGF0ZShmYWxzZSk7CiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1hbnVhbElucHV0KSB7CiAgICAgICAgICB0aGlzLiRlbWl0KCdibHVyJywgdGhpcy5nZXRGdWxsRGF0YSgpKTsKICAgICAgICB9CgogICAgICAgIHRoaXMuaXNGb2N1c2luZyA9IGZhbHNlOwoKICAgICAgICBpZiAodGhpcy5sYXp5KSB7CiAgICAgICAgICB0aGlzLmZpbGxWYWx1ZXModHJ1ZSk7CiAgICAgICAgICB0aGlzLmJha0Rpc3BsYXlUaW1lID0gdW5kZWZpbmVkOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHRoaXMucmVzdHJpY3RlZEhvdXJSYW5nZSAmJiB0aGlzLmJhc2VPbjEySG91cnMpIHsKICAgICAgICB0aGlzLnNob3dEcm9wZG93biA/IHRoaXMuZm9yY2VBcG1TZWxlY3Rpb24oKSA6IHRoaXMuZW1wdHlBcG1TZWxlY3Rpb24oKTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuc2hvd0Ryb3Bkb3duKSB7CiAgICAgICAgdGhpcy5jaGVja0ZvckF1dG9TY3JvbGwoKTsKICAgICAgfQogICAgfSwKICAgIHNldERyb3Bkb3duU3RhdGU6IGZ1bmN0aW9uIHNldERyb3Bkb3duU3RhdGUodG9TaG93KSB7CiAgICAgIHZhciBmcm9tVXNlckNsaWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKCiAgICAgIGlmICh0b1Nob3cpIHsKICAgICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkpIHsKICAgICAgICAgIHRoaXMuYXBwZW5kRHJvcGRvd25Ub0JvZHkoKTsKICAgICAgICB9CgogICAgICAgIHRoaXMua2VlcEZvY3VzaW5nKCk7CgogICAgICAgIGlmICh0aGlzLmF1dG9EaXJlY3Rpb25FbmFibGVkKSB7CiAgICAgICAgICB0aGlzLmNoZWNrRHJvcERpcmVjdGlvbigpOwogICAgICAgIH0KCiAgICAgICAgdGhpcy5zaG93RHJvcGRvd24gPSB0cnVlOwogICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKTsKCiAgICAgICAgaWYgKGZyb21Vc2VyQ2xpY2spIHsKICAgICAgICAgIGlmICh0aGlzLmZpeGVkRHJvcGRvd25CdXR0b24pIHsKICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIHRoaXMuZ2V0RnVsbERhdGEoKSk7CiAgICAgICAgICB0aGlzLmNoZWNrRm9yQXV0b1Njcm9sbCgpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLnNob3dEcm9wZG93biA9IGZhbHNlOwogICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJywgdGhpcy5nZXRGdWxsRGF0YSgpKTsKCiAgICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5KSB7CiAgICAgICAgICB0aGlzLnJlbW92ZURyb3Bkb3duRnJvbUJvZHkoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBhcHBlbmREcm9wZG93blRvQm9keTogZnVuY3Rpb24gYXBwZW5kRHJvcGRvd25Ub0JvZHkoKSB7CiAgICAgIHZhciBkcm9wZG93biA9IHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bjsKICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdOwoKICAgICAgaWYgKGJvZHkgJiYgZHJvcGRvd24pIHsKICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy51cGRhdGVEcm9wZG93blBvcyk7CiAgICAgICAgZHJvcGRvd24uY2xhc3NMaXN0LmFkZCgndnVlX190aW1lLXBpY2tlci1kcm9wZG93bicpOwogICAgICAgIHRoaXMudXBkYXRlRHJvcGRvd25Qb3MoKTsKICAgICAgICBib2R5LmFwcGVuZENoaWxkKGRyb3Bkb3duKTsKICAgICAgfQogICAgfSwKICAgIHVwZGF0ZURyb3Bkb3duUG9zOiBmdW5jdGlvbiB1cGRhdGVEcm9wZG93blBvcygpIHsKICAgICAgaWYgKCF0aGlzLmFwcGVuZFRvQm9keSkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGRyb3Bkb3duID0gdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duOwogICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07CgogICAgICBpZiAoYm9keSAmJiBkcm9wZG93bikgewogICAgICAgIHZhciBib3ggPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKCiAgICAgICAgaWYgKHRoaXMuZHJvcGRvd25EaXJDbGFzcyA9PT0gJ2Ryb3AtdXAnKSB7CiAgICAgICAgICBkcm9wZG93bi5zdHlsZS5ib3R0b20gPSAiIi5jb25jYXQod2luZG93LmlubmVySGVpZ2h0IC0gYm94LnksICJweCIpOwogICAgICAgICAgZHJvcGRvd24uc3R5bGUudG9wID0gJ2F1dG8nOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBkcm9wZG93bi5zdHlsZS50b3AgPSAiIi5jb25jYXQoYm94LnkgKyBib3guaGVpZ2h0LCAicHgiKTsKICAgICAgICAgIGRyb3Bkb3duLnN0eWxlLmJvdHRvbSA9ICdhdXRvJzsKICAgICAgICB9CgogICAgICAgIGRyb3Bkb3duLnN0eWxlLmxlZnQgPSAiIi5jb25jYXQoYm94LngsICJweCIpOwogICAgICB9CiAgICB9LAogICAgcmVtb3ZlRHJvcGRvd25Gcm9tQm9keTogZnVuY3Rpb24gcmVtb3ZlRHJvcGRvd25Gcm9tQm9keSgpIHsKICAgICAgdmFyIGRyb3Bkb3duID0gdGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmRyb3Bkb3duOwogICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07CgogICAgICBpZiAoYm9keSAmJiBkcm9wZG93biAmJiBib2R5LmNvbnRhaW5zKGRyb3Bkb3duKSkgewogICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoZHJvcGRvd24pOwogICAgICB9CgogICAgICBpZiAoZHJvcGRvd24pIHsKICAgICAgICBkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKCd2dWVfX3RpbWUtcGlja2VyLWRyb3Bkb3duJyk7CiAgICAgICAgZHJvcGRvd24uc3R5bGUudG9wID0gJyc7CiAgICAgICAgZHJvcGRvd24uc3R5bGUuYm90dG9tID0gJyc7CiAgICAgICAgZHJvcGRvd24uc3R5bGUubGVmdCA9ICcnOwogICAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGRyb3Bkb3duKTsKICAgICAgfQoKICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudXBkYXRlRHJvcGRvd25Qb3MpOwogICAgfSwKICAgIGJsdXJFdmVudDogZnVuY3Rpb24gYmx1ckV2ZW50KCkgewogICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCAmJiAhdGhpcy5vcHRzLmhpZGVEcm9wZG93bikgewogICAgICAgIC8vIGhpZGVEcm9wZG93bidzIGBibHVyYCBldmVudCBpcyBoYW5kbGVkIHNvbWV3aGVyZSBlbHNlCiAgICAgICAgdGhpcy4kZW1pdCgnYmx1cicsIHRoaXMuZ2V0RnVsbERhdGEoKSk7CiAgICAgIH0KICAgIH0sCiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdCh0eXBlLCB2YWx1ZSkgewogICAgICBpZiAodGhpcy5pc0Jhc2ljVHlwZSh0eXBlKSAmJiAhdGhpcy5pc0Rpc2FibGVkKHR5cGUsIHZhbHVlKSkgewogICAgICAgIHRoaXNbdHlwZV0gPSB2YWx1ZTsKCiAgICAgICAgaWYgKHRoaXMuZG9DbGVhckFwbUNoZWNraW5nKSB7CiAgICAgICAgICB0aGlzLmRvQ2xlYXJBcG1DaGVja2luZyA9IGZhbHNlOwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIGNsZWFyVGltZTogZnVuY3Rpb24gY2xlYXJUaW1lKCkgewogICAgICBpZiAodGhpcy5kaXNhYmxlZCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdGhpcy5ob3VyID0gJyc7CiAgICAgIHRoaXMubWludXRlID0gJyc7CiAgICAgIHRoaXMuc2Vjb25kID0gJyc7CiAgICAgIHRoaXMuYXBtID0gJyc7CgogICAgICBpZiAodGhpcy5tYW51YWxJbnB1dCAmJiB0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC52YWx1ZS5sZW5ndGgpIHsKICAgICAgICB0aGlzLiRyZWZzLmlucHV0LnZhbHVlID0gJyc7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmxhenkpIHsKICAgICAgICB0aGlzLmZpbGxWYWx1ZXModHJ1ZSk7CiAgICAgIH0KICAgIH0sCiAgICAvLwogICAgLy8gQXV0by1TY3JvbGwKICAgIC8vCiAgICBjaGVja0ZvckF1dG9TY3JvbGw6IGZ1bmN0aW9uIGNoZWNrRm9yQXV0b1Njcm9sbCgpIHsKICAgICAgdmFyIF90aGlzMTIgPSB0aGlzOwoKICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAodGhpcy5hdXRvU2Nyb2xsKSB7CiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkgewogICAgICAgICAgX3RoaXMxMi5zY3JvbGxUb1NlbGVjdGVkVmFsdWVzKCk7CiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5hZHZhbmNlZEtleWJvYXJkKSB7CiAgICAgICAgLy8gQXV0by1mb2N1cyBvbiBzZWxlY3RlZCB2YWx1ZSBpbiB0aGUgZmlyc3QgY29sdW1uIGZvciBhZHZhbmNlZC1rZXlib2FyZAogICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBmaXJzdENvbHVtbiA9IF90aGlzMTIuaW5Vc2UudHlwZXNbMF07CgogICAgICAgICAgX3RoaXMxMi5zY3JvbGxUb1NlbGVjdGVkKGZpcnN0Q29sdW1uLCB0cnVlKTsKICAgICAgICB9KTsKICAgICAgfQogICAgfSwKICAgIHNjcm9sbFRvU2VsZWN0ZWQ6IGZ1bmN0aW9uIHNjcm9sbFRvU2VsZWN0ZWQoY29sdW1uKSB7CiAgICAgIHZhciBhbGxvd0ZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKCiAgICAgIGlmICghdGhpcy50aW1lVmFsdWUgfHwgdGhpcy5pbnB1dElzRW1wdHkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciB0YXJnZXRMaXN0OwoKICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bikgewogICAgICAgIHRhcmdldExpc3QgPSB0aGlzLiRyZWZzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoInVsLiIuY29uY2F0KGNvbHVtbiwgInMiKSlbMF07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFyZ2V0TGlzdCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoInVsLiIuY29uY2F0KGNvbHVtbiwgInMiKSlbMF07CiAgICAgIH0KCiAgICAgIHZhciB0YXJnZXRWYWx1ZSA9IHRoaXMuYWN0aXZlSXRlbUluQ29sKGNvbHVtbilbMF07CgogICAgICBpZiAoIXRhcmdldFZhbHVlICYmIGFsbG93RmFsbGJhY2spIHsKICAgICAgICAvLyBObyB2YWx1ZSBzZWxlY3RlZCBpbiB0aGUgdGFyZ2V0IGNvbHVtbiwgZmFsbGJhY2sgdG8gdGhlIGZpcnN0IGZvdW5kIHZhbGlkIGl0ZW0KICAgICAgICB0YXJnZXRWYWx1ZSA9IHRoaXMudmFsaWRJdGVtc0luQ29sKGNvbHVtbilbMF07CiAgICAgIH0KCiAgICAgIGlmICh0YXJnZXRMaXN0ICYmIHRhcmdldFZhbHVlKSB7CiAgICAgICAgdGFyZ2V0TGlzdC5zY3JvbGxUb3AgPSB0YXJnZXRWYWx1ZS5vZmZzZXRUb3AgfHwgMDsKCiAgICAgICAgaWYgKHRoaXMuYWR2YW5jZWRLZXlib2FyZCkgewogICAgICAgICAgdGFyZ2V0VmFsdWUuZm9jdXMoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBzY3JvbGxUb1NlbGVjdGVkVmFsdWVzOiBmdW5jdGlvbiBzY3JvbGxUb1NlbGVjdGVkVmFsdWVzKCkgewogICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7CgogICAgICBpZiAoIXRoaXMudGltZVZhbHVlIHx8IHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB0aGlzLmluVXNlLnR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24pIHsKICAgICAgICBfdGhpczEzLnNjcm9sbFRvU2VsZWN0ZWQoc2VjdGlvbik7CiAgICAgIH0pOwogICAgfSwKICAgIC8vCiAgICAvLyBBZGRpdGlvbmFsIEtleWJvYXJkIE5hdmlnYXRpb24KICAgIC8vCiAgICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkgewogICAgICBpZiAodGhpcy5kaXNhYmxlZCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgaWYgKCF0aGlzLmlzRm9jdXNpbmcpIHsKICAgICAgICB0aGlzLmlzRm9jdXNpbmcgPSB0cnVlOwogICAgICB9CgogICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHsKICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZSgpOwogICAgICB9CiAgICB9LAogICAgZXNjQmx1cjogZnVuY3Rpb24gZXNjQmx1cigpIHsKICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKTsKICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gZmFsc2U7CiAgICAgIHZhciBpbnB1dEJveCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LmRpc3BsYXktdGltZScpWzBdOwoKICAgICAgaWYgKGlucHV0Qm94KSB7CiAgICAgICAgaW5wdXRCb3guYmx1cigpOwogICAgICB9CiAgICB9LAogICAgZGVib3VuY2VCbHVyOiBmdW5jdGlvbiBkZWJvdW5jZUJsdXIoKSB7CiAgICAgIHZhciBfdGhpczE0ID0gdGhpczsKCiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB0aGlzLmlzRm9jdXNpbmcgPSBmYWxzZTsKICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpOwogICAgICB0aGlzLmRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChfdGhpczE0LmRlYm91bmNlVGltZXIpOwoKICAgICAgICBfdGhpczE0Lm9uQmx1cigpOwogICAgICB9LCB0aGlzLm9wdHMuYmx1ckRlbGF5KTsKICAgIH0sCiAgICBvbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHsKICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmICF0aGlzLmlzRm9jdXNpbmcgJiYgdGhpcy5pc0FjdGl2ZSkgewogICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlKCk7CiAgICAgIH0KICAgIH0sCiAgICBrZWVwRm9jdXNpbmc6IGZ1bmN0aW9uIGtlZXBGb2N1c2luZygpIHsKICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVyKTsKCiAgICAgIGlmICghdGhpcy5pc0ZvY3VzaW5nKSB7CiAgICAgICAgdGhpcy5pc0ZvY3VzaW5nID0gdHJ1ZTsKICAgICAgfQogICAgfSwKICAgIG9uVGFiOiBmdW5jdGlvbiBvblRhYihjb2x1bW4sIHZhbHVlLCBldnQpIHsKICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIGV2dC5zaGlmdEtleSkgewogICAgICAgIHZhciBmaXJzdENvbHVtbiA9IHRoaXMuaW5Vc2UudHlwZXNbMF07CgogICAgICAgIGlmIChjb2x1bW4gIT09IGZpcnN0Q29sdW1uKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB2YXIgZmlyc3RWYWxpZFZhbHVlID0gdGhpcy52YWxpZEl0ZW1zSW5Db2woZmlyc3RDb2x1bW4pWzBdOyAvLyBJcyB0aGUgZmlyc3QgdmFsaWQgaXRlbSBpbiB0aGUgZmlyc3QgY29sdW1uCgogICAgICAgIGlmIChmaXJzdFZhbGlkVmFsdWUgJiYgZmlyc3RWYWxpZFZhbHVlLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKSA9PT0gU3RyaW5nKHZhbHVlKSkgewogICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7IC8vIEZvY3VzIGJhY2sgb24gPGlucHV0PgoKICAgICAgICAgIGlmICh0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuaW5wdXQpIHsKICAgICAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIHZhbGlkSXRlbXNJbkNvbDogZnVuY3Rpb24gdmFsaWRJdGVtc0luQ29sKGNvbHVtbikgewogICAgICB2YXIgY29sdW1uQ2xhc3MgPSAiIi5jb25jYXQoY29sdW1uLCAicyIpOwoKICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bikgewogICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoInVsLiIuY29uY2F0KGNvbHVtbkNsYXNzLCAiID4gbGk6bm90KC5oaW50KTpub3QoW2Rpc2FibGVkXSkiKSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCJ1bC4iLmNvbmNhdChjb2x1bW5DbGFzcywgIiA+IGxpOm5vdCguaGludCk6bm90KFtkaXNhYmxlZF0pIikpOwogICAgfSwKICAgIGFjdGl2ZUl0ZW1JbkNvbDogZnVuY3Rpb24gYWN0aXZlSXRlbUluQ29sKGNvbHVtbikgewogICAgICB2YXIgY29sdW1uQ2xhc3MgPSAiIi5jb25jYXQoY29sdW1uLCAicyIpOwoKICAgICAgaWYgKHRoaXMuYXBwZW5kVG9Cb2R5ICYmIHRoaXMuJHJlZnMgJiYgdGhpcy4kcmVmcy5kcm9wZG93bikgewogICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3JBbGwoInVsLiIuY29uY2F0KGNvbHVtbkNsYXNzLCAiID4gbGkuYWN0aXZlOm5vdCguaGludCkiKSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCJ1bC4iLmNvbmNhdChjb2x1bW5DbGFzcywgIiA+IGxpLmFjdGl2ZTpub3QoLmhpbnQpIikpOwogICAgfSwKICAgIGdldENsb3Nlc3RTaWJsaW5nOiBmdW5jdGlvbiBnZXRDbG9zZXN0U2libGluZyhjb2x1bW4sIGRhdGFLZXkpIHsKICAgICAgdmFyIGdldFByZXZpb3VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTsKICAgICAgdmFyIHNpYmxpbmdzSW5Db2wgPSB0aGlzLnZhbGlkSXRlbXNJbkNvbChjb2x1bW4pOwogICAgICB2YXIgc2VsZkluZGV4ID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleC5jYWxsKHNpYmxpbmdzSW5Db2wsIGZ1bmN0aW9uIChzYmwpIHsKICAgICAgICByZXR1cm4gc2JsLmdldEF0dHJpYnV0ZSgnZGF0YS1rZXknKSA9PT0gZGF0YUtleTsKICAgICAgfSk7IC8vIEFscmVhZHkgdGhlIGZpcnN0IGl0ZW0KCiAgICAgIGlmIChnZXRQcmV2aW91cyAmJiBzZWxmSW5kZXggPT09IDApIHsKICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFtzaWJsaW5nc0luQ29sLmxlbmd0aCAtIDFdOwogICAgICB9IC8vIEFscmVhZHkgdGhlIGxhc3QgaXRlbQoKCiAgICAgIGlmICghZ2V0UHJldmlvdXMgJiYgc2VsZkluZGV4ID09PSBzaWJsaW5nc0luQ29sLmxlbmd0aCAtIDEpIHsKICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFswXTsKICAgICAgfSAvLyBTZWxlY3RlZCB2YWx1ZSBub3QgaW4gdGhlIHZhbGlkIHZhbHVlcyBsaXN0CgoKICAgICAgaWYgKHNlbGZJbmRleCA8IDApIHsKICAgICAgICByZXR1cm4gc2libGluZ3NJbkNvbFswXTsKICAgICAgfQoKICAgICAgaWYgKGdldFByZXZpb3VzKSB7CiAgICAgICAgcmV0dXJuIHNpYmxpbmdzSW5Db2xbc2VsZkluZGV4IC0gMV07CiAgICAgIH0KCiAgICAgIHJldHVybiBzaWJsaW5nc0luQ29sW3NlbGZJbmRleCArIDFdOwogICAgfSwKICAgIHByZXZJdGVtOiBmdW5jdGlvbiBwcmV2SXRlbShjb2x1bW4sIGRhdGFLZXkpIHsKICAgICAgdmFyIGlzTWFudWFsSW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlOwogICAgICB2YXIgdGFyZ2V0SXRlbSA9IHRoaXMuZ2V0Q2xvc2VzdFNpYmxpbmcoY29sdW1uLCBkYXRhS2V5LCB0cnVlKTsKCiAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgcmV0dXJuIGlzTWFudWFsSW5wdXQgPyB0YXJnZXRJdGVtIDogdGFyZ2V0SXRlbS5mb2N1cygpOwogICAgICB9CiAgICB9LAogICAgbmV4dEl0ZW06IGZ1bmN0aW9uIG5leHRJdGVtKGNvbHVtbiwgZGF0YUtleSkgewogICAgICB2YXIgaXNNYW51YWxJbnB1dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7CiAgICAgIHZhciB0YXJnZXRJdGVtID0gdGhpcy5nZXRDbG9zZXN0U2libGluZyhjb2x1bW4sIGRhdGFLZXksIGZhbHNlKTsKCiAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgcmV0dXJuIGlzTWFudWFsSW5wdXQgPyB0YXJnZXRJdGVtIDogdGFyZ2V0SXRlbS5mb2N1cygpOwogICAgICB9CiAgICB9LAogICAgZ2V0U2lkZUNvbHVtbk5hbWU6IGZ1bmN0aW9uIGdldFNpZGVDb2x1bW5OYW1lKGN1cnJlbnRDb2x1bW4pIHsKICAgICAgdmFyIHRvTGVmdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7CiAgICAgIHZhciBjdXJyZW50Q29sdW1uSW5kZXggPSB0aGlzLmluVXNlLnR5cGVzLmluZGV4T2YoY3VycmVudENvbHVtbik7CgogICAgICBpZiAodG9MZWZ0ICYmIGN1cnJlbnRDb2x1bW5JbmRleCA8PSAwKSB7CiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSBsZWZ0bW9zdCBsaXN0IGFscmVhZHknKTsKICAgICAgICB9CgogICAgICAgIHJldHVybjsKICAgICAgfSBlbHNlIGlmICghdG9MZWZ0ICYmIGN1cnJlbnRDb2x1bW5JbmRleCA9PT0gdGhpcy5pblVzZS50eXBlcy5sZW5ndGggLSAxKSB7CiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSByaWdodG1vc3QgbGlzdCBhbHJlYWR5Jyk7CiAgICAgICAgfQoKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHJldHVybiB0aGlzLmluVXNlLnR5cGVzW3RvTGVmdCA/IGN1cnJlbnRDb2x1bW5JbmRleCAtIDEgOiBjdXJyZW50Q29sdW1uSW5kZXggKyAxXTsKICAgIH0sCiAgICBnZXRGaXJzdEl0ZW1JblNpZGVDb2x1bW46IGZ1bmN0aW9uIGdldEZpcnN0SXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uKSB7CiAgICAgIHZhciB0b0xlZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlOwogICAgICB2YXIgdGFyZ2V0Q29sdW1uID0gdGhpcy5nZXRTaWRlQ29sdW1uTmFtZShjdXJyZW50Q29sdW1uLCB0b0xlZnQpOwoKICAgICAgaWYgKCF0YXJnZXRDb2x1bW4pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBsaXN0SXRlbXMgPSB0aGlzLnZhbGlkSXRlbXNJbkNvbCh0YXJnZXRDb2x1bW4pOwoKICAgICAgaWYgKGxpc3RJdGVtcyAmJiBsaXN0SXRlbXNbMF0pIHsKICAgICAgICByZXR1cm4gbGlzdEl0ZW1zWzBdOwogICAgICB9CiAgICB9LAogICAgZ2V0QWN0aXZlSXRlbUluU2lkZUNvbHVtbjogZnVuY3Rpb24gZ2V0QWN0aXZlSXRlbUluU2lkZUNvbHVtbihjdXJyZW50Q29sdW1uKSB7CiAgICAgIHZhciB0b0xlZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlOwogICAgICB2YXIgdGFyZ2V0Q29sdW1uID0gdGhpcy5nZXRTaWRlQ29sdW1uTmFtZShjdXJyZW50Q29sdW1uLCB0b0xlZnQpOwoKICAgICAgaWYgKCF0YXJnZXRDb2x1bW4pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBhY3RpdmVJdGVtcyA9IHRoaXMuYWN0aXZlSXRlbUluQ29sKHRhcmdldENvbHVtbik7CgogICAgICBpZiAoYWN0aXZlSXRlbXMgJiYgYWN0aXZlSXRlbXNbMF0pIHsKICAgICAgICByZXR1cm4gYWN0aXZlSXRlbXNbMF07CiAgICAgIH0KICAgIH0sCiAgICB0b0xlZnRDb2x1bW46IGZ1bmN0aW9uIHRvTGVmdENvbHVtbihjdXJyZW50Q29sdW1uKSB7CiAgICAgIHZhciB0YXJnZXRJdGVtID0gdGhpcy5nZXRBY3RpdmVJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIHRydWUpIHx8IHRoaXMuZ2V0Rmlyc3RJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIHRydWUpOwoKICAgICAgaWYgKHRhcmdldEl0ZW0pIHsKICAgICAgICB0YXJnZXRJdGVtLmZvY3VzKCk7CiAgICAgIH0KICAgIH0sCiAgICB0b1JpZ2h0Q29sdW1uOiBmdW5jdGlvbiB0b1JpZ2h0Q29sdW1uKGN1cnJlbnRDb2x1bW4pIHsKICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0aGlzLmdldEFjdGl2ZUl0ZW1JblNpZGVDb2x1bW4oY3VycmVudENvbHVtbiwgZmFsc2UpIHx8IHRoaXMuZ2V0Rmlyc3RJdGVtSW5TaWRlQ29sdW1uKGN1cnJlbnRDb2x1bW4sIGZhbHNlKTsKCiAgICAgIGlmICh0YXJnZXRJdGVtKSB7CiAgICAgICAgdGFyZ2V0SXRlbS5mb2N1cygpOwogICAgICB9CiAgICB9LAogICAgLy8KICAgIC8vIE1hbnVhbCBJbnB1dAogICAgLy8KICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiBvbk1vdXNlRG93bigpIHsKICAgICAgdmFyIF90aGlzMTUgPSB0aGlzOwoKICAgICAgaWYgKCF0aGlzLm1hbnVhbElucHV0KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpOwogICAgICB0aGlzLnNlbGVjdGlvblRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoX3RoaXMxNS5zZWxlY3Rpb25UaW1lcik7CgogICAgICAgIGlmIChfdGhpczE1LiRyZWZzICYmIF90aGlzMTUuJHJlZnMuaW5wdXQpIHsKICAgICAgICAgIHZhciBuZWFyZXN0U2xvdCA9IF90aGlzMTUuZ2V0TmVhcmVzdENodW5rQnlQb3MoX3RoaXMxNS4kcmVmcy5pbnB1dC5zZWxlY3Rpb25TdGFydCB8fCAwKTsKCiAgICAgICAgICBfdGhpczE1LmRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24obmVhcmVzdFNsb3QpOwogICAgICAgIH0KICAgICAgfSwgNTApOwogICAgfSwKICAgIGtleURvd25IYW5kbGVyOiBmdW5jdGlvbiBrZXlEb3duSGFuZGxlcihldnQpIHsKICAgICAgaWYgKGV2dC5pc0NvbXBvc2luZyB8fCBldnQua2V5Q29kZSA9PT0gMjI5KSB7CiAgICAgICAgLy8gU2tpcCBJTUUgaW5wdXRzCiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOwogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfSAvLyBOdW1iZXJzCgoKICAgICAgaWYgKGV2dC5rZXlDb2RlID49IDQ4ICYmIGV2dC5rZXlDb2RlIDw9IDU3IHx8IGV2dC5rZXlDb2RlID49IDk2ICYmIGV2dC5rZXlDb2RlIDw9IDEwNSkgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIHRoaXMua2V5Ym9hcmRJbnB1dChldnQua2V5KTsgLy8gQXxQfE0KICAgICAgfSBlbHNlIGlmIChbNjUsIDgwLCA3N10uaW5jbHVkZXMoZXZ0LmtleUNvZGUpKSB7CiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgdGhpcy5rZXlib2FyZElucHV0KGV2dC5rZXksIHRydWUpOyAvLyBBcnJvdyBrZXlzCiAgICAgIH0gZWxzZSBpZiAoZXZ0LmtleUNvZGUgPj0gMzcgJiYgZXZ0LmtleUNvZGUgPD0gNDApIHsKICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsKICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpOwogICAgICAgIHRoaXMuYXJyb3dIYW5kbGVyKGV2dCk7IC8vIERlbGV0ZXxCYWNrc3BhY2UKICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gOCB8fCBldnQua2V5Q29kZSA9PT0gNDYpIHsKICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsKICAgICAgICB0aGlzLmNsZWFyS2JJbnB1dExvZygpOwogICAgICAgIHRoaXMuY2xlYXJUaW1lKCk7IC8vIFRhYgogICAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlID09PSA5KSB7CiAgICAgICAgdGhpcy5jbGVhcktiSW5wdXRMb2coKTsKICAgICAgICB0aGlzLnRhYkhhbmRsZXIoZXZ0KTsgLy8gQ29sb258U3BhY2UKICAgICAgfSBlbHNlIGlmIChldnQua2V5Q29kZSA9PT0gMTg2IHx8IGV2dC5rZXlDb2RlID09PSAzMikgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIHRoaXMuY2xlYXJLYklucHV0TG9nKCk7CiAgICAgICAgdGhpcy50b05leHRTbG90KCk7IC8vIFByZXZlbnQgYW55IE5vbi1FU0MgYW5kIG5vbi1wYXN0aW5nIGlucHV0cwogICAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlICE9PSAyNyAmJiAhKGV2dC5tZXRhS2V5IHx8IGV2dC5jdHJsS2V5KSkgewogICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICB9CiAgICB9LAogICAgb25Db21wb3N0aW9uU3RhcnQ6IGZ1bmN0aW9uIG9uQ29tcG9zdGlvblN0YXJ0KGV2dCkgewogICAgICBldnQucHJldmVudERlZmF1bHQoKTsKICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpOwogICAgICB0aGlzLmJha0N1cnJlbnRQb3MgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCk7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0sCiAgICBvbkNvbXBvc3Rpb25FbmQ6IGZ1bmN0aW9uIG9uQ29tcG9zdGlvbkVuZChldnQpIHsKICAgICAgdmFyIF90aGlzMTYgPSB0aGlzOwoKICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7CiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTsKICAgICAgdmFyIGNwc0RhdGEgPSBldnQuZGF0YTsKICAgICAgdmFyIGlucHV0SXNDdXN0b21BcG1UZXh0ID0gZmFsc2U7CgogICAgICBpZiAodGhpcy5oYXMuY3VzdG9tQXBtVGV4dCkgewogICAgICAgIGlucHV0SXNDdXN0b21BcG1UZXh0ID0gdGhpcy5pc0N1c3RvbUFwbVRleHQoY3BzRGF0YSk7CiAgICAgIH0KCiAgICAgIGlmIChpbnB1dElzQ3VzdG9tQXBtVGV4dCkgewogICAgICAgIHRoaXMuc2V0U2FuaXRpemVkVmFsdWVUb1NlY3Rpb24oJ2FwbScsIGlucHV0SXNDdXN0b21BcG1UZXh0KTsKICAgICAgfQoKICAgICAgdGhpcy4kcmVmcy5pbnB1dC52YWx1ZSA9IHRoaXMuaGFzLmN1c3RvbUFwbVRleHQgPyB0aGlzLmN1c3RvbURpc3BsYXlUaW1lIDogdGhpcy5kaXNwbGF5VGltZTsKICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkgewogICAgICAgIGlmIChfdGhpczE2LmJha0N1cnJlbnRQb3MpIHsKICAgICAgICAgIHZhciBiYWtQb3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KF90aGlzMTYuYmFrQ3VycmVudFBvcykpOwoKICAgICAgICAgIGlmIChpbnB1dElzQ3VzdG9tQXBtVGV4dCkgewogICAgICAgICAgICBiYWtQb3MuZW5kID0gYmFrUG9zLnN0YXJ0ICsgY3BzRGF0YS5sZW5ndGg7CiAgICAgICAgICB9CgogICAgICAgICAgX3RoaXMxNi5kZWJvdW5jZVNldElucHV0U2VsZWN0aW9uKGJha1Bvcyk7CgogICAgICAgICAgX3RoaXMxNi5iYWtDdXJyZW50UG9zID0gbnVsbDsKICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gZmFsc2U7CiAgICB9LAogICAgcGFzdGVIYW5kbGVyOiBmdW5jdGlvbiBwYXN0ZUhhbmRsZXIoZXZ0KSB7CiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICB2YXIgcGFzdGluZ1RleHQgPSAoZXZ0LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGEpLmdldERhdGEoJ3RleHQnKTsKCiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgIHRoaXMuZGVidWdMb2coIlBhc3RpbmcgdmFsdWUgXCIiLmNvbmNhdChwYXN0aW5nVGV4dCwgIlwiIGZyb20gY2xpcGJvYXJkIikpOwogICAgICB9CgogICAgICBpZiAoIXBhc3RpbmdUZXh0IHx8ICFwYXN0aW5nVGV4dC5sZW5ndGgpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0gLy8gUmVwbGFjZSBjdXN0b20gQU0vUE0gdGV4dCAoaWYgYW55KQoKCiAgICAgIGlmICh0aGlzLmhhcy5jdXN0b21BcG1UZXh0KSB7CiAgICAgICAgcGFzdGluZ1RleHQgPSB0aGlzLnJlcGxhY2VDdXN0b21BcG1UZXh0KHBhc3RpbmdUZXh0KTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgdGhpcy5yZWFkU3RyaW5nVmFsdWVzKHBhc3RpbmdUZXh0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLmtiSW5wdXRMb2cgPSBwYXN0aW5nVGV4dC5zdWJzdHIoLTIsIDIpOwogICAgICAgIHRoaXMuc2V0S2JJbnB1dCgpOwogICAgICAgIHRoaXMuZGVib3VuY2VDbGVhcktiTG9nKCk7CiAgICAgIH0KICAgIH0sCiAgICBhcnJvd0hhbmRsZXI6IGZ1bmN0aW9uIGFycm93SGFuZGxlcihldnQpIHsKICAgICAgdmFyIGRpcmVjdGlvbiA9IHsKICAgICAgICAzNzogJ0wnLAogICAgICAgIDM4OiAnVScsCiAgICAgICAgMzk6ICdSJywKICAgICAgICA0MDogJ0QnCiAgICAgIH1bZXZ0LmtleUNvZGVdOwoKICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ1UnIHx8IGRpcmVjdGlvbiA9PT0gJ0QnKSB7CiAgICAgICAgaWYgKHRoaXMuaW5wdXRJc0VtcHR5KSB7CiAgICAgICAgICB0aGlzLnNlbGVjdEZpcnN0VmFsaWRWYWx1ZSgpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpOwoKICAgICAgICAgIGlmICghY3VycmVudENodW5rKSB7CiAgICAgICAgICAgIHRoaXMuc2VsZWN0Rmlyc3RWYWxpZFZhbHVlKCk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KCiAgICAgICAgICB2YXIgdG9rZW5UeXBlID0gY3VycmVudENodW5rLnR5cGU7CiAgICAgICAgICB0aGlzLmdldENsb3Nlc3RWYWxpZEl0ZW1JbkNvbCh0b2tlblR5cGUsIHRoaXNbdG9rZW5UeXBlXSwgZGlyZWN0aW9uKTsKICAgICAgICAgIHZhciBuZXdDaHVua1BvcyA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKTsKICAgICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZXdDaHVua1Bvcyk7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ1InKSB7CiAgICAgICAgdGhpcy50b0xhdGVyYWxUb2tlbihmYWxzZSk7CiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnTCcpIHsKICAgICAgICB0aGlzLnRvTGF0ZXJhbFRva2VuKHRydWUpOwogICAgICB9CiAgICB9LAogICAgdGFiSGFuZGxlcjogZnVuY3Rpb24gdGFiSGFuZGxlcihldnQpIHsKICAgICAgaWYgKCF0aGlzLmlucHV0SXNFbXB0eSAmJiB0aGlzLnRva2VuQ2h1bmtzUG9zICYmIHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoKSB7CiAgICAgICAgdmFyIGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKTsKCiAgICAgICAgaWYgKCFjdXJyZW50Q2h1bmspIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CgogICAgICAgIHZhciBmaXJzdENodW5rID0gdGhpcy50b2tlbkNodW5rc1Bvc1swXTsKICAgICAgICB2YXIgbGFzdENodW5rID0gdGhpcy50b2tlbkNodW5rc1Bvc1t0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCAtIDFdOwoKICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5ICYmIGN1cnJlbnRDaHVuay50b2tlbiAhPT0gZmlyc3RDaHVuay50b2tlbiB8fCAhZXZ0LnNoaWZ0S2V5ICYmIGN1cnJlbnRDaHVuay50b2tlbiAhPT0gbGFzdENodW5rLnRva2VuKSB7CiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsKICAgICAgICAgIHRoaXMudG9MYXRlcmFsVG9rZW4oZXZ0LnNoaWZ0S2V5KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodGhpcy5hcHBlbmRUb0JvZHkgJiYgdGhpcy5hZHZhbmNlZEtleWJvYXJkKSB7CiAgICAgICAgaWYgKGV2dC5zaGlmdEtleSkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7CgogICAgICAgIGlmICh0aGlzLmlucHV0SXNFbXB0eSkgewogICAgICAgICAgdmFyIGZpcnN0Q29sdW1uID0gdGhpcy5pblVzZS50eXBlc1swXTsKICAgICAgICAgIHZhciB0YXJnZXRWYWx1ZSA9IHRoaXMudmFsaWRJdGVtc0luQ29sKGZpcnN0Q29sdW1uKVswXTsKCiAgICAgICAgICBpZiAodGFyZ2V0VmFsdWUpIHsKICAgICAgICAgICAgdGFyZ2V0VmFsdWUuZm9jdXMoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBrZXlib2FyZElucHV0OiBmdW5jdGlvbiBrZXlib2FyZElucHV0KG5ld0NoYXIpIHsKICAgICAgdmFyIGlzQXBtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTsKICAgICAgdmFyIGN1cnJlbnRDaHVuayA9IHRoaXMuZ2V0Q3VycmVudFRva2VuQ2h1bmsoKTsKCiAgICAgIGlmICghY3VycmVudENodW5rIHx8IGN1cnJlbnRDaHVuay50eXBlICE9PSAnYXBtJyAmJiBpc0FwbSB8fCBjdXJyZW50Q2h1bmsudHlwZSA9PT0gJ2FwbScgJiYgIWlzQXBtKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB0aGlzLmtiSW5wdXRMb2cgPSAiIi5jb25jYXQodGhpcy5rYklucHV0TG9nLnN1YnN0cigtMSkpLmNvbmNhdChuZXdDaGFyKTsKICAgICAgdGhpcy5zZXRLYklucHV0KCk7CiAgICAgIHRoaXMuZGVib3VuY2VDbGVhcktiTG9nKCk7CiAgICB9LAogICAgY2xlYXJLYklucHV0TG9nOiBmdW5jdGlvbiBjbGVhcktiSW5wdXRMb2coKSB7CiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5rYklucHV0VGltZXIpOwogICAgICB0aGlzLmtiSW5wdXRMb2cgPSAnJzsKICAgIH0sCiAgICBkZWJvdW5jZUNsZWFyS2JMb2c6IGZ1bmN0aW9uIGRlYm91bmNlQ2xlYXJLYkxvZygpIHsKICAgICAgdmFyIF90aGlzMTcgPSB0aGlzOwoKICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmtiSW5wdXRUaW1lcik7CiAgICAgIHRoaXMua2JJbnB1dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICAgIF90aGlzMTcuY2xlYXJLYklucHV0TG9nKCk7CiAgICAgIH0sIHRoaXMub3B0cy5tYW51YWxJbnB1dFRpbWVvdXQpOwogICAgfSwKICAgIHNldEtiSW5wdXQ6IGZ1bmN0aW9uIHNldEtiSW5wdXQodmFsdWUpIHsKICAgICAgdmFsdWUgPSB2YWx1ZSB8fCB0aGlzLmtiSW5wdXRMb2c7CiAgICAgIHZhciBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCk7CgogICAgICBpZiAoIWN1cnJlbnRDaHVuayB8fCAhdmFsdWUgfHwgIXZhbHVlLmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGNodW5rVHlwZSA9IGN1cnJlbnRDaHVuay50eXBlOwogICAgICB2YXIgY2h1bmtUb2tlbiA9IGN1cnJlbnRDaHVuay50b2tlbjsKICAgICAgdmFyIHZhbGlkVmFsdWU7CgogICAgICBpZiAoY2h1bmtUeXBlID09PSAnYXBtJykgewogICAgICAgIGlmICh0aGlzLmxvd2VyQ2FzZWRBcG0odmFsdWUpLmluY2x1ZGVzKCdhJykpIHsKICAgICAgICAgIHZhbGlkVmFsdWUgPSAnYW0nOwogICAgICAgIH0gZWxzZSBpZiAodGhpcy5sb3dlckNhc2VkQXBtKHZhbHVlKS5pbmNsdWRlcygncCcpKSB7CiAgICAgICAgICB2YWxpZFZhbHVlID0gJ3BtJzsKICAgICAgICB9CgogICAgICAgIGlmICh2YWxpZFZhbHVlKSB7CiAgICAgICAgICB2YWxpZFZhbHVlID0gY2h1bmtUb2tlbiA9PT0gJ0EnID8gdmFsaWRWYWx1ZS50b1VwcGVyQ2FzZSgpIDogdmFsaWRWYWx1ZTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFZhbHVlKGNodW5rVG9rZW4sIHZhbHVlKSkgewogICAgICAgICAgdmFsaWRWYWx1ZSA9IHZhbHVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgbGFzdElucHV0VmFsdWUgPSB0aGlzLmZvcm1hdFZhbHVlKGNodW5rVG9rZW4sIHZhbHVlLnN1YnN0cigtMSkpOwoKICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRWYWx1ZShjaHVua1Rva2VuLCBsYXN0SW5wdXRWYWx1ZSkpIHsKICAgICAgICAgICAgdmFsaWRWYWx1ZSA9IGxhc3RJbnB1dFZhbHVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKHZhbGlkVmFsdWUpIHsKICAgICAgICB0aGlzLnNldFNhbml0aXplZFZhbHVlVG9TZWN0aW9uKGNodW5rVHlwZSwgdmFsaWRWYWx1ZSk7CiAgICAgICAgdmFyIG5ld0NodW5rUG9zID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpOwogICAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihuZXdDaHVua1Bvcyk7CiAgICAgIH0KCiAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSkgewogICAgICAgIGlmICh2YWxpZFZhbHVlKSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCJTdWNjZXNzZnVsbHkgc2V0IHZhbHVlIFwiIi5jb25jYXQodmFsaWRWYWx1ZSwgIlwiIGZyb20gbGF0ZXN0IGlucHV0IFwiIikuY29uY2F0KHZhbHVlLCAiXCIgZm9yIHRoZSBcIiIpLmNvbmNhdChjaHVua1R5cGUsICJcIiBzbG90IikpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzLmRlYnVnTG9nKCJWYWx1ZSBcIiIuY29uY2F0KHZhbHVlLCAiXCIgaXMgaW52YWxpZCBpbiB0aGUgXCIiKS5jb25jYXQoY2h1bmtUeXBlLCAiXCIgc2xvdCIpKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICAvLyBGb3JtIEF1dG9maWxsCiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoKSB7CiAgICAgIGlmICghdGhpcy5tYW51YWxJbnB1dCB8fCAhdGhpcy4kcmVmcyB8fCAhdGhpcy4kcmVmcy5pbnB1dCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGF1dG9GaWxsVmFsdWUgPSB0aGlzLiRyZWZzLmlucHV0LnZhbHVlIHx8ICcnOwoKICAgICAgaWYgKGF1dG9GaWxsVmFsdWUgJiYgYXV0b0ZpbGxWYWx1ZS5sZW5ndGgpIHsKICAgICAgICB0aGlzLnJlYWRTdHJpbmdWYWx1ZXMoYXV0b0ZpbGxWYWx1ZSk7CiAgICAgIH0KICAgIH0sCiAgICBnZXROZWFyZXN0Q2h1bmtCeVBvczogZnVuY3Rpb24gZ2V0TmVhcmVzdENodW5rQnlQb3Moc3RhcnRQb3MpIHsKICAgICAgaWYgKCF0aGlzLnRva2VuQ2h1bmtzUG9zIHx8ICF0aGlzLnRva2VuQ2h1bmtzUG9zLmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIG5lYXJlc3Q7CiAgICAgIHZhciBuZWFyZXN0RGVsdGEgPSAtMTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBjaHVuayA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy50b2tlbkNodW5rc1Bvc1tpXSkpOwoKICAgICAgICBpZiAoY2h1bmsuc3RhcnQgPT09IHN0YXJ0UG9zKSB7CiAgICAgICAgICByZXR1cm4gY2h1bms7CiAgICAgICAgfQoKICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhjaHVuay5zdGFydCAtIHN0YXJ0UG9zKTsKCiAgICAgICAgaWYgKG5lYXJlc3REZWx0YSA8IDApIHsKICAgICAgICAgIG5lYXJlc3QgPSBjaHVuazsKICAgICAgICAgIG5lYXJlc3REZWx0YSA9IGRlbHRhOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAobmVhcmVzdERlbHRhIDw9IGRlbHRhKSB7CiAgICAgICAgICAgIHJldHVybiBuZWFyZXN0OwogICAgICAgICAgfQoKICAgICAgICAgIG5lYXJlc3REZWx0YSA9IGRlbHRhOwogICAgICAgICAgbmVhcmVzdCA9IGNodW5rOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIG5lYXJlc3Q7CiAgICB9LAogICAgc2VsZWN0Rmlyc3RWYWxpZFZhbHVlOiBmdW5jdGlvbiBzZWxlY3RGaXJzdFZhbGlkVmFsdWUoKSB7CiAgICAgIGlmICghdGhpcy50b2tlbkNodW5rc1BvcyB8fCAhdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGgpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBmaXJzdFNsb3RUeXBlID0gdGhpcy50b2tlbkNodW5rc1Bvc1swXS50eXBlOwoKICAgICAgaWYgKGZpcnN0U2xvdFR5cGUgPT09ICdob3VyJykgewogICAgICAgIHRoaXMuZ2V0Q2xvc2VzdEhvdXJJdGVtKCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5nZXRDbG9zZXN0VmFsaWRJdGVtSW5Db2woZmlyc3RTbG90VHlwZSwgdGhpc1tmaXJzdFNsb3RUeXBlXSk7CiAgICAgIH0KCiAgICAgIHRoaXMuc2VsZWN0Rmlyc3RTbG90KCk7CiAgICB9LAogICAgZ2V0Q2xvc2VzdEhvdXJJdGVtOiBmdW5jdGlvbiBnZXRDbG9zZXN0SG91ckl0ZW0oY3VycmVudFZhbHVlKSB7CiAgICAgIHZhciBfdGhpczE4ID0gdGhpczsKCiAgICAgIHZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdVJzsKCiAgICAgIGlmICghdGhpcy52YWxpZEhvdXJzTGlzdCB8fCAhdGhpcy52YWxpZEhvdXJzTGlzdC5sZW5ndGgpIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIHRoaXMuZGVidWdMb2coIk5vIHZhbGlkIGhvdXIgdmFsdWVzIGZvdW5kLCBwbGVhc2UgY2hlY2sgeW91ciBcImhvdXItcmFuZ2VcIiBjb25maWdcbmhvdXItcmFuZ2U6ICIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMuaG91clJhbmdlKSkpOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBpZiAoIWN1cnJlbnRWYWx1ZSkgewogICAgICAgIHRoaXMuc2V0TWFudWFsSG91cih0aGlzLnZhbGlkSG91cnNMaXN0WzBdKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnZhbGlkSG91cnNMaXN0LmZpbmRJbmRleChmdW5jdGlvbiAoaXRlbSkgewogICAgICAgIGlmICghX3RoaXMxOC5iYXNlT24xMkhvdXJzKSB7CiAgICAgICAgICByZXR1cm4gaXRlbSA9PT0gY3VycmVudFZhbHVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgdmFsdWVLZXkgPSAiIi5jb25jYXQoY3VycmVudFZhbHVlKS5jb25jYXQoX3RoaXMxOC5sb3dlckNhc2VkQXBtKF90aGlzMTguYXBtKSA9PT0gJ3BtJyA/ICdwJyA6ICdhJyk7CiAgICAgICAgICByZXR1cm4gaXRlbSA9PT0gdmFsdWVLZXk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgdmFyIG5leHRJbmRleDsKCiAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7CiAgICAgICAgbmV4dEluZGV4ID0gMDsKICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdEJykgewogICAgICAgIG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCA9PT0gMCA/IHRoaXMudmFsaWRIb3Vyc0xpc3QubGVuZ3RoIC0gMSA6IGN1cnJlbnRJbmRleCAtIDE7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbmV4dEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpICUgdGhpcy52YWxpZEhvdXJzTGlzdC5sZW5ndGg7CiAgICAgIH0KCiAgICAgIHZhciBuZXh0SXRlbSA9IHRoaXMudmFsaWRIb3Vyc0xpc3RbbmV4dEluZGV4XTsKICAgICAgdGhpcy5zZXRNYW51YWxIb3VyKG5leHRJdGVtKTsKICAgIH0sCiAgICBnZXRDbG9zZXN0VmFsaWRJdGVtSW5Db2w6IGZ1bmN0aW9uIGdldENsb3Nlc3RWYWxpZEl0ZW1JbkNvbChjb2x1bW4sIGN1cnJlbnRWYWx1ZSkgewogICAgICB2YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnVSc7CgogICAgICBpZiAoY29sdW1uID09PSAnaG91cicpIHsKICAgICAgICB0aGlzLmdldENsb3Nlc3RIb3VySXRlbShjdXJyZW50VmFsdWUsIGRpcmVjdGlvbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIG5leHRJdGVtID0gZGlyZWN0aW9uID09PSAnRCcgPyB0aGlzLnByZXZJdGVtKGNvbHVtbiwgdGhpc1tjb2x1bW5dLCB0cnVlKSA6IHRoaXMubmV4dEl0ZW0oY29sdW1uLCB0aGlzW2NvbHVtbl0sIHRydWUpOwoKICAgICAgICBpZiAobmV4dEl0ZW0pIHsKICAgICAgICAgIHRoaXMuc2VsZWN0KGNvbHVtbiwgbmV4dEl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWtleScpKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBzZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbjogZnVuY3Rpb24gc2V0U2FuaXRpemVkVmFsdWVUb1NlY3Rpb24oc2VjdGlvbiwgaW5wdXRWYWx1ZSkgewogICAgICBpZiAoIXNlY3Rpb24gfHwgIXRoaXMuZ2V0VG9rZW5CeVR5cGUoc2VjdGlvbikpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0gLy8gTk9URTogRGlzYWJsZWQgdmFsdWVzIGFyZSBhbGxvd2VkIGhlcmUsIGZvbGxvd2VkIGJ5IGFuICdlcnJvcicgZXZlbnQsIHRob3VnaAoKCiAgICAgIHZhciBzYW5pdGl6ZWRWYWx1ZSA9IHRoaXMuc2FuaXRpemVkVmFsdWUodGhpcy5nZXRUb2tlbkJ5VHlwZShzZWN0aW9uKSwgaW5wdXRWYWx1ZSk7CiAgICAgIHRoaXNbc2VjdGlvbl0gPSBzYW5pdGl6ZWRWYWx1ZTsKICAgIH0sCiAgICBzZXRNYW51YWxIb3VyOiBmdW5jdGlvbiBzZXRNYW51YWxIb3VyKG5leHRJdGVtKSB7CiAgICAgIGlmICh0aGlzLmlzMTJoUmFuZ2UobmV4dEl0ZW0pKSB7CiAgICAgICAgdmFyIGhvdXJUID0gdGhpcy5tYXRjaDEyaFJhbmdlKG5leHRJdGVtKTsKICAgICAgICB2YXIgYXBtVmFsdWUgPSBob3VyVFsyXSA9PT0gJ2EnID8gJ0FNJyA6ICdQTSc7CiAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbignYXBtJywgdGhpcy5hcG1UeXBlID09PSAnYScgPyBhcG1WYWx1ZS50b0xvd2VyQ2FzZSgpIDogYXBtVmFsdWUpOwogICAgICAgIHRoaXMuc2V0U2FuaXRpemVkVmFsdWVUb1NlY3Rpb24oJ2hvdXInLCBob3VyVFsxXSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5zZXRTYW5pdGl6ZWRWYWx1ZVRvU2VjdGlvbignaG91cicsIG5leHRJdGVtKTsKICAgICAgfQogICAgfSwKICAgIGRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb246IGZ1bmN0aW9uIGRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24oX3JlZikgewogICAgICB2YXIgX3RoaXMxOSA9IHRoaXM7CgogICAgICB2YXIgX3JlZiRzdGFydCA9IF9yZWYuc3RhcnQsCiAgICAgICAgICBzdGFydCA9IF9yZWYkc3RhcnQgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHN0YXJ0LAogICAgICAgICAgX3JlZiRlbmQgPSBfcmVmLmVuZCwKICAgICAgICAgIGVuZCA9IF9yZWYkZW5kID09PSB2b2lkIDAgPyAwIDogX3JlZiRlbmQ7CiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHsKICAgICAgICBfdGhpczE5LnNldElucHV0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICAgIH0pOwogICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpOwogICAgICB0aGlzLnNlbGVjdGlvblRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoX3RoaXMxOS5zZWxlY3Rpb25UaW1lcik7IC8vIERvdWJsZS1jaGVjayBzZWxlY3Rpb24gZm9yIDEyaHIgZm9ybWF0CgogICAgICAgIGlmIChfdGhpczE5LiRyZWZzLmlucHV0ICYmIChfdGhpczE5LiRyZWZzLmlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSBzdGFydCB8fCBfdGhpczE5LiRyZWZzLmlucHV0LnNlbGVjdGlvbkVuZCAhPT0gZW5kKSkgewogICAgICAgICAgX3RoaXMxOS5zZXRJbnB1dFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpOwogICAgICAgIH0KICAgICAgfSwgMzApOwogICAgfSwKICAgIHNldElucHV0U2VsZWN0aW9uUmFuZ2U6IGZ1bmN0aW9uIHNldElucHV0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCkgewogICAgICBpZiAodGhpcy4kcmVmcyAmJiB0aGlzLiRyZWZzLmlucHV0KSB7CiAgICAgICAgdGhpcy4kcmVmcy5pbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTsKICAgICAgfQogICAgfSwKICAgIGdldEN1cnJlbnRUb2tlbkNodW5rOiBmdW5jdGlvbiBnZXRDdXJyZW50VG9rZW5DaHVuaygpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0TmVhcmVzdENodW5rQnlQb3ModGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LnNlbGVjdGlvblN0YXJ0IHx8IDApOwogICAgfSwKICAgIHNlbGVjdEZpcnN0U2xvdDogZnVuY3Rpb24gc2VsZWN0Rmlyc3RTbG90KCkgewogICAgICB2YXIgZmlyc3RDaHVua1BvcyA9IHRoaXMuZ2V0TmVhcmVzdENodW5rQnlQb3MoMCk7CiAgICAgIHRoaXMuZGVib3VuY2VTZXRJbnB1dFNlbGVjdGlvbihmaXJzdENodW5rUG9zKTsKICAgIH0sCiAgICB0b05leHRTbG90OiBmdW5jdGlvbiB0b05leHRTbG90KCkgewogICAgICBpZiAoIXRoaXMuaW5wdXRJc0VtcHR5ICYmIHRoaXMudG9rZW5DaHVua3NQb3MgJiYgdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGgpIHsKICAgICAgICB2YXIgY3VycmVudENodW5rID0gdGhpcy5nZXRDdXJyZW50VG9rZW5DaHVuaygpOwoKICAgICAgICBpZiAoIWN1cnJlbnRDaHVuaykgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgdmFyIGxhc3RDaHVuayA9IHRoaXMudG9rZW5DaHVua3NQb3NbdGhpcy50b2tlbkNodW5rc1Bvcy5sZW5ndGggLSAxXTsKCiAgICAgICAgaWYgKGN1cnJlbnRDaHVuay50b2tlbiAhPT0gbGFzdENodW5rLnRva2VuKSB7CiAgICAgICAgICB0aGlzLnRvTGF0ZXJhbFRva2VuKGZhbHNlKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICB0b0xhdGVyYWxUb2tlbjogZnVuY3Rpb24gdG9MYXRlcmFsVG9rZW4odG9MZWZ0KSB7CiAgICAgIHZhciBjdXJyZW50Q2h1bmsgPSB0aGlzLmdldEN1cnJlbnRUb2tlbkNodW5rKCk7CgogICAgICBpZiAoIWN1cnJlbnRDaHVuaykgewogICAgICAgIHRoaXMuc2VsZWN0Rmlyc3RWYWxpZFZhbHVlKCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgY3VycmVudENodW5rSW5kZXggPSB0aGlzLnRva2VuQ2h1bmtzUG9zLmZpbmRJbmRleChmdW5jdGlvbiAoY2hrKSB7CiAgICAgICAgcmV0dXJuIGNoay50b2tlbiA9PT0gY3VycmVudENodW5rLnRva2VuOwogICAgICB9KTsKCiAgICAgIGlmICghdG9MZWZ0ICYmIGN1cnJlbnRDaHVua0luZGV4ID49IHRoaXMudG9rZW5DaHVua3NQb3MubGVuZ3RoIC0gMSB8fCB0b0xlZnQgJiYgY3VycmVudENodW5rSW5kZXggPT09IDApIHsKICAgICAgICBpZiAodGhpcy5kZWJ1Z01vZGUpIHsKICAgICAgICAgIGlmICh0b0xlZnQpIHsKICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZygnWW91XCdyZSBpbiB0aGUgbGVmdG1vc3Qgc2xvdCBhbHJlYWR5Jyk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0aGlzLmRlYnVnTG9nKCdZb3VcJ3JlIGluIHRoZSByaWdodG1vc3Qgc2xvdCBhbHJlYWR5Jyk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciB0YXJnZXRTbG90UG9zID0gdG9MZWZ0ID8gdGhpcy50b2tlbkNodW5rc1Bvc1tjdXJyZW50Q2h1bmtJbmRleCAtIDFdIDogdGhpcy50b2tlbkNodW5rc1Bvc1tjdXJyZW50Q2h1bmtJbmRleCArIDFdOwogICAgICB0aGlzLmRlYm91bmNlU2V0SW5wdXRTZWxlY3Rpb24odGFyZ2V0U2xvdFBvcyk7CiAgICB9LAogICAgaXNDdXN0b21BcG1UZXh0OiBmdW5jdGlvbiBpc0N1c3RvbUFwbVRleHQoaW5wdXREYXRhKSB7CiAgICAgIGlmICghaW5wdXREYXRhIHx8ICFpbnB1dERhdGEubGVuZ3RoKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAodGhpcy5hbVRleHQgJiYgdGhpcy5hbVRleHQgPT09IGlucHV0RGF0YSkgewogICAgICAgIHJldHVybiB0aGlzLmFwbVR5cGUgPT09ICdBJyA/ICdBTScgOiAnYW0nOwogICAgICB9CgogICAgICBpZiAodGhpcy5wbVRleHQgJiYgdGhpcy5wbVRleHQgPT09IGlucHV0RGF0YSkgewogICAgICAgIHJldHVybiB0aGlzLmFwbVR5cGUgPT09ICdBJyA/ICdQTScgOiAncG0nOwogICAgICB9CgogICAgICByZXR1cm4gZmFsc2U7CiAgICB9LAogICAgcmVwbGFjZUN1c3RvbUFwbVRleHQ6IGZ1bmN0aW9uIHJlcGxhY2VDdXN0b21BcG1UZXh0KGlucHV0U3RyaW5nKSB7CiAgICAgIGlmICh0aGlzLmFtVGV4dCAmJiB0aGlzLmFtVGV4dC5sZW5ndGggJiYgaW5wdXRTdHJpbmcuaW5jbHVkZXModGhpcy5hbVRleHQpKSB7CiAgICAgICAgcmV0dXJuIGlucHV0U3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLmFtVGV4dCwgJ2cnKSwgdGhpcy5hcG1UeXBlID09PSAnQScgPyAnQU0nIDogJ2FtJyk7CiAgICAgIH0gZWxzZSBpZiAodGhpcy5wbVRleHQgJiYgdGhpcy5wbVRleHQubGVuZ3RoICYmIGlucHV0U3RyaW5nLmluY2x1ZGVzKHRoaXMucG1UZXh0KSkgewogICAgICAgIHJldHVybiBpbnB1dFN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5wbVRleHQsICdnJyksIHRoaXMuYXBtVHlwZSA9PT0gJ0EnID8gJ1BNJyA6ICdwbScpOwogICAgICB9CgogICAgICByZXR1cm4gaW5wdXRTdHJpbmc7CiAgICB9LAogICAgY2hlY2tEcm9wRGlyZWN0aW9uOiBmdW5jdGlvbiBjaGVja0Ryb3BEaXJlY3Rpb24oKSB7CiAgICAgIGlmICghdGhpcy4kZWwpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHZhciBjb250YWluZXI7CgogICAgICBpZiAodGhpcy5jb250YWluZXJJZCAmJiB0aGlzLmNvbnRhaW5lcklkLmxlbmd0aCkgewogICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29udGFpbmVySWQpOwoKICAgICAgICBpZiAoIWNvbnRhaW5lciAmJiB0aGlzLmRlYnVnTW9kZSkgewogICAgICAgICAgdGhpcy5kZWJ1Z0xvZygiQ29udGFpbmVyIHdpdGggaWQgXCIiLmNvbmNhdCh0aGlzLmNvbnRhaW5lcklkLCAiXCIgbm90IGZvdW5kLiBGYWxsYmFjayB0byBkb2N1bWVudCBib2R5LiIpKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBlbCA9IHRoaXMuJGVsOwogICAgICB2YXIgc3BhY2VEb3duOwoKICAgICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIub2Zmc2V0SGVpZ2h0KSB7CiAgICAgICAgLy8gVmFsaWQgY29udGFpbmVyIGZvdW5kCiAgICAgICAgc3BhY2VEb3duID0gY29udGFpbmVyLm9mZnNldFRvcCArIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSAoZWwub2Zmc2V0VG9wICsgZWwub2Zmc2V0SGVpZ2h0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBGYWxsYmFjayB0byBkb2N1bWVudCBib2R5CiAgICAgICAgdmFyIGRvY0hlaWdodCA9IE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpOwogICAgICAgIHNwYWNlRG93biA9IGRvY0hlaWdodCAtIChlbC5vZmZzZXRUb3AgKyBlbC5vZmZzZXRIZWlnaHQpOwogICAgICB9CgogICAgICB0aGlzLmZvcmNlRHJvcE9uVG9wID0gdGhpcy5vcHRzLmRyb3BPZmZzZXRIZWlnaHQgPiBzcGFjZURvd247CiAgICB9LAogICAgLy8KICAgIC8vIEhlbHBlcnMKICAgIC8vCiAgICBpczEyaFJhbmdlOiBmdW5jdGlvbiBpczEyaFJhbmdlKHZhbHVlKSB7CiAgICAgIHJldHVybiAvXlxkezEsMn0oYXxwfEF8UCkkLy50ZXN0KHZhbHVlKTsKICAgIH0sCiAgICBtYXRjaDEyaFJhbmdlOiBmdW5jdGlvbiBtYXRjaDEyaFJhbmdlKHZhbHVlKSB7CiAgICAgIHJldHVybiB2YWx1ZS5tYXRjaCgvXihcZHsxLDJ9KShhfHB8QXxQKSQvKTsKICAgIH0sCiAgICBpc051bWJlcjogZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHsKICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpOwogICAgfSwKICAgIGlzQmFzaWNUeXBlOiBmdW5jdGlvbiBpc0Jhc2ljVHlwZSh0eXBlKSB7CiAgICAgIHJldHVybiBDT05GSUcuQkFTSUNfVFlQRVMuaW5jbHVkZXModHlwZSk7CiAgICB9LAogICAgbG93ZXJDYXNlZEFwbTogZnVuY3Rpb24gbG93ZXJDYXNlZEFwbShhcG1WYWx1ZSkgewogICAgICByZXR1cm4gKGFwbVZhbHVlIHx8ICcnKS50b0xvd2VyQ2FzZSgpOwogICAgfSwKICAgIGdldFRva2VuUmVnZXg6IGZ1bmN0aW9uIGdldFRva2VuUmVnZXgodG9rZW4pIHsKICAgICAgc3dpdGNoICh0b2tlbikgewogICAgICAgIGNhc2UgJ0hIJzoKICAgICAgICAgIHJldHVybiAnKFswMV1bMC05XXwyWzAtM118SHsyfSknOwoKICAgICAgICBjYXNlICdIJzoKICAgICAgICAgIHJldHVybiAnKFswLTldezF9fDFbMC05XXwyWzAtM118SHsxfSknOwoKICAgICAgICBjYXNlICdoaCc6CiAgICAgICAgICByZXR1cm4gJygwWzEtOV18MVswLTJdfGh7Mn0pJzsKCiAgICAgICAgY2FzZSAnaCc6CiAgICAgICAgICByZXR1cm4gJyhbMS05XXsxfXwxWzAtMl18aHsxfSknOwoKICAgICAgICBjYXNlICdrayc6CiAgICAgICAgICByZXR1cm4gJygwWzEtOV18MVswLTldfDJbMC00XXxrezJ9KSc7CgogICAgICAgIGNhc2UgJ2snOgogICAgICAgICAgcmV0dXJuICcoWzEtOV17MX18MVswLTldfDJbMC00XXxrezF9KSc7CgogICAgICAgIGNhc2UgJ21tJzoKICAgICAgICAgIHJldHVybiAnKFswLTVdWzAtOV18bXsyfSknOwoKICAgICAgICBjYXNlICdzcyc6CiAgICAgICAgICByZXR1cm4gJyhbMC01XVswLTldfHN7Mn0pJzsKCiAgICAgICAgY2FzZSAnbSc6CiAgICAgICAgICByZXR1cm4gJyhbMC05XXsxfXxbMS01XVswLTldfG17MX0pJzsKCiAgICAgICAgY2FzZSAncyc6CiAgICAgICAgICByZXR1cm4gJyhbMC05XXsxfXxbMS01XVswLTldfHN7MX0pJzsKCiAgICAgICAgY2FzZSAnQSc6CiAgICAgICAgICByZXR1cm4gJyhBTXxQTXxBezF9KSc7CgogICAgICAgIGNhc2UgJ2EnOgogICAgICAgICAgcmV0dXJuICcoYW18cG18YXsxfSknOwoKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgcmV0dXJuICcnOwogICAgICB9CiAgICB9LAogICAgaXNFbXB0eVZhbHVlOiBmdW5jdGlvbiBpc0VtcHR5VmFsdWUodGFyZ2V0VG9rZW4sIHRlc3RWYWx1ZSkgewogICAgICByZXR1cm4gIXRlc3RWYWx1ZSB8fCAhdGVzdFZhbHVlLmxlbmd0aCB8fCB0ZXN0VmFsdWUgJiYgdGVzdFZhbHVlID09PSB0YXJnZXRUb2tlbjsKICAgIH0sCiAgICBpc1ZhbGlkVmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRWYWx1ZSh0YXJnZXRUb2tlbiwgdGVzdFZhbHVlKSB7CiAgICAgIGlmICghdGFyZ2V0VG9rZW4gfHwgdGhpcy5pc0VtcHR5VmFsdWUodGFyZ2V0VG9rZW4sIHRlc3RWYWx1ZSkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHZhciB0b2tlblJlZ2V4U3RyID0gdGhpcy5nZXRUb2tlblJlZ2V4KHRhcmdldFRva2VuKTsKCiAgICAgIGlmICghdG9rZW5SZWdleFN0ciB8fCAhdG9rZW5SZWdleFN0ci5sZW5ndGgpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgUmVnRXhwKCJeIi5jb25jYXQodG9rZW5SZWdleFN0ciwgIiQiKSkudGVzdCh0ZXN0VmFsdWUpOwogICAgfSwKICAgIHNhbml0aXplZFZhbHVlOiBmdW5jdGlvbiBzYW5pdGl6ZWRWYWx1ZSh0YXJnZXRUb2tlbiwgaW5wdXRWYWx1ZSkgewogICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUodGFyZ2V0VG9rZW4sIGlucHV0VmFsdWUpKSB7CiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7CiAgICAgIH0KCiAgICAgIHJldHVybiAnJzsKICAgIH0sCiAgICBnZXRUb2tlblR5cGU6IGZ1bmN0aW9uIGdldFRva2VuVHlwZSh0b2tlbikgewogICAgICByZXR1cm4gdGhpcy5pblVzZS50eXBlc1t0aGlzLmluVXNlLnRva2Vucy5pbmRleE9mKHRva2VuKV0gfHwgJyc7CiAgICB9LAogICAgZ2V0VG9rZW5CeVR5cGU6IGZ1bmN0aW9uIGdldFRva2VuQnlUeXBlKHR5cGUpIHsKICAgICAgcmV0dXJuIHRoaXNbIiIuY29uY2F0KHR5cGUsICJUeXBlIildIHx8ICcnOwogICAgfSwKICAgIGlzTWludXRlT3JTZWNvbmQ6IGZ1bmN0aW9uIGlzTWludXRlT3JTZWNvbmQodHlwZSkgewogICAgICByZXR1cm4gWydtaW51dGUnLCAnc2Vjb25kJ10uaW5jbHVkZXModHlwZSk7CiAgICB9LAogICAgZGVidWdMb2c6IGZ1bmN0aW9uIGRlYnVnTG9nKGxvZ1RleHQpIHsKICAgICAgdmFyIF90aGlzMjAgPSB0aGlzOwoKICAgICAgaWYgKCFsb2dUZXh0IHx8ICFsb2dUZXh0Lmxlbmd0aCkgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgdmFyIGlkZW50aWZpZXIgPSAnJzsKCiAgICAgIGlmICh0aGlzLmlkKSB7CiAgICAgICAgaWRlbnRpZmllciArPSAiIyIuY29uY2F0KHRoaXMuaWQpOwogICAgICB9CgogICAgICBpZiAodGhpcy5uYW1lKSB7CiAgICAgICAgaWRlbnRpZmllciArPSAiW25hbWU9Ii5jb25jYXQodGhpcy5uYW1lLCAiXSIpOwogICAgICB9CgogICAgICBpZiAodGhpcy5pbnB1dENsYXNzKSB7CiAgICAgICAgdmFyIGlucHV0Q2xhc3NlcyA9IFtdOwoKICAgICAgICBpZiAodHlwZW9mIHRoaXMuaW5wdXRDbGFzcyA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIGlucHV0Q2xhc3NlcyA9IHRoaXMuaW5wdXRDbGFzcy5zcGxpdCgvXHMvZyk7CiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuaW5wdXRDbGFzcykpIHsKICAgICAgICAgIGlucHV0Q2xhc3NlcyA9IFtdLmNvbmNhdChbXSwgdGhpcy5pbnB1dENsYXNzKTsKICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YodGhpcy5pbnB1dENsYXNzKSA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuaW5wdXRDbGFzcykuZm9yRWFjaChmdW5jdGlvbiAoY2xzTmFtZSkgewogICAgICAgICAgICBpZiAoX3RoaXMyMC5pbnB1dENsYXNzW2Nsc05hbWVdKSB7CiAgICAgICAgICAgICAgaW5wdXRDbGFzc2VzLnB1c2goY2xzTmFtZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbnB1dENsYXNzZXMpLAogICAgICAgICAgICBfc3RlcDQ7CgogICAgICAgIHRyeSB7CiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykgewogICAgICAgICAgICB2YXIgaW5wdXRDbGFzcyA9IF9zdGVwNC52YWx1ZTsKCiAgICAgICAgICAgIGlmIChpbnB1dENsYXNzICYmIGlucHV0Q2xhc3MudHJpbSgpLmxlbmd0aCkgewogICAgICAgICAgICAgIGlkZW50aWZpZXIgKz0gIi4iLmNvbmNhdChpbnB1dENsYXNzLnRyaW0oKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpOwogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBfaXRlcmF0b3I0LmYoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBmaW5hbExvZ1RleHQgPSAiREVCVUc6ICIuY29uY2F0KGxvZ1RleHQpLmNvbmNhdChpZGVudGlmaWVyID8gIlxuXHQoIi5jb25jYXQoaWRlbnRpZmllciwgIikiKSA6ICcnKTsKCiAgICAgIGlmICh3aW5kb3cuY29uc29sZS5kZWJ1ZyAmJiB0eXBlb2Ygd2luZG93LmNvbnNvbGUuZGVidWcgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICB3aW5kb3cuY29uc29sZS5kZWJ1ZyhmaW5hbExvZ1RleHQpOwogICAgICB9IGVsc2UgewogICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhmaW5hbExvZ1RleHQpOwogICAgICB9CiAgICB9CiAgfSwKICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkgewogICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpOwogICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnNlbGVjdGlvblRpbWVyKTsKICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5rYklucHV0VGltZXIpOwogICAgdGhpcy5yZW5kZXJGb3JtYXQoKTsKICB9LAogIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7CiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VUaW1lcik7CiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2VsZWN0aW9uVGltZXIpOwogICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmtiSW5wdXRUaW1lcik7CiAgfQp9Ow=="},{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACAA,gDADA;AAEAC,4BAFA;AAGAC,4BAHA;AAIAC,wBAJA;AAKAC;AALA;AAQA;AACAC,iBADA;AAEAC,mBAFA;AAGAC,mBAHA;AAIAC,iBAJA;AAKAC,mBALA;AAMAC,mBANA;AAOAC,0BAPA;AAQAC,4BARA;AASAC,4BATA;AAUAC,0BAVA;AAWAC,qBAXA;AAYAC,gBAZA;AAaAC,0BAbA;AAcAC;AAdA;AAiBA;AACAC,uBADA;AAEAC;AACAC;AAAAC;AAAA,KADA;AAEAjB;AAAAiB;AAAA,KAFA;AAGAhB;AAAAgB;AAAA,KAHA;AAIAf;AAAAe;AAAA,KAJA;AAMAd;AAAAc;AAAA,KANA;AAOAb;AAAAa;AAAA,KAPA;AAQAZ;AAAAY;AAAA,KARA;AAUAX;AAAAW;AAAAC;AAAA,KAVA;AAWAX;AAAAU;AAAAC;AAAA,KAXA;AAYAV;AAAAS;AAAAC;AAAA,KAZA;AAaAT;AAAAQ;AAAAC;AAAA,KAbA;AAeAC;AAAAF;AAAAC;AAAA,KAfA;AAgBAE;AAAAH;AAAAC;AAAA,KAhBA;AAiBAG;AAAAJ;AAAAC;AAAA,KAjBA;AAmBAI;AAAAL;AAAA,KAnBA;AAoBAH;AAAAG;AAAA,KApBA;AAqBAM;AAAAN;AAAA,KArBA;AAsBAO;AAAAP;AAAA,KAtBA;AAuBAQ;AAAAR;AAAAC;AAAA,KAvBA;AAwBAQ;AAAAT;AAAA,KAxBA;AAyBAU;AAAAV;AAAAC;AAAA,KAzBA;AA2BAU;AAAAX;AAAA,KA3BA;AA4BAY;AAAAZ;AAAA,KA5BA;AA6BAa;AAAAb;AAAA,KA7BA;AA8BAc;AAAAd;AAAA,KA9BA;AA+BAe;AAAAf;AAAA,KA/BA;AAgCAgB;AAAAhB;AAAA,KAhCA;AAkCAN;AAAAM;AAAA,KAlCA;AAmCAiB;AAAAjB;AAAAC;AAAA,KAnCA;AAqCAiB;AAAAlB;AAAAC;AAAA,KArCA;AAsCAkB;AAAAnB;AAAAC;AAAA,KAtCA;AAwCAmB;AAAApB;AAAAC;AAAA,KAxCA;AAyCAL;AAAAI;AAAA,KAzCA;AA0CAqB;AAAArB;AAAA,KA1CA;AA2CAsB;AAAAtB;AAAAC;AAAA,KA3CA;AA6CAsB;AAAAvB;AAAAC;AAAA,KA7CA;AA8CAN;AAAAK;AAAA,KA9CA;AA+CAP;AAAAO;AAAAC;AAAA,KA/CA;AAgDAuB;AAAAxB;AAAAC;AAAA,KAhDA;AAkDAwB;AAAAzB;AAAAC;AAAA;AAlDA,GAFA;AAuDAyB,MAvDA,kBAuDA;AACA;AACAC,mBADA;AAGAC,eAHA;AAIAC,iBAJA;AAKAC,iBALA;AAMAC,cANA;AAQAC,qBARA;AASAC,yBATA;AAUAC,uBAVA;AAWAC,8BAXA;AAaAC,oBAbA;AAcAC,sBAdA;AAeAC,oBAfA;AAgBAC,iBAhBA;AAiBAC,cAjBA;AAkBAC,gBAlBA;AAmBAC,gBAnBA;AAoBAC,aApBA;AAqBAC,2BArBA;AAsBAC,+BAtBA;AAuBAC,+BAvBA;AAyBAC,+BAzBA;AA0BAC,6BA1BA;AA2BAC,oBA3BA;AA4BAC,8BA5BA;AA6BAC;AA7BA;AA+BA,GAvFA;AAyFAC;AACAC,QADA,kBACA;AACA;;AAEA;AACAC;AACA;;AAEA;AACAA;AACA,OATA,CAUA;;;AACA;AACA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA;;AACA;AACAA;AACA,SAFA,MAEA;AACAA;AACA;AACA;;AAEA;AACAA;AACA,OA5BA,CA6BA;;;AACA;AACA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA;;AACA;AACAA;AACA,SAFA,MAEA;AACAA;AACA;AACA;;AAEA;AACAA;;AACA;AACA;AACA;AACA;;AAEA;AACAA;;AACA;AACA;AACA;AACA;;AAEA;AACAA;;AACA;AACA;AACA;AACA;;AAEA;AACAA;AACA;;AAEA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AAEA;AACA;AACAA;AACA,SAFA,MAEA;AACA;AACA;AACA;;AAEA;AACAA;AACA;;AAEA;AACAA;AACA;;AAEA;AACAA;AACA;;AAEA;AACA,KAtGA;AAwGAC,kBAxGA,4BAwGA;AACA;AACA,KA1GA;AA4GAC,gBA5GA,0BA4GA;AACA;AACA,KA9GA;AAgHAC,SAhHA,mBAgHA;AAAA;;AACA;AAAA;AAAA,SADA,CAEA;;AACAC;AACA;AACA,OAFA;AAGA;AAAA;AAAA;AACA;AACAlB,6BADA;AAEAC,iCAFA;AAGAC,iCAHA;AAIAC,2BAJA;AAKAgB,+BALA;AAMAC;AANA;AAQA,KA/HA;AAiIAC,eAjIA,yBAiIA;AACA;;AACA;AACAL;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACA,KAhJA;AAkJAM,qBAlJA,+BAkJA;AACA;AACA;AACA;;AACA;AACA,KAvJA;AAyJAC,gBAzJA,0BAyJA;AACA;AACA,KA3JA;AA6JAC,oBA7JA,8BA6JA;AACA,UACA,iCACA,iCADA,IAEA,iCAFA,IAGA,2BAJA,EAKA;AACA;AACA;;AACA;AACA,KAvKA;AAyKAC,mBAzKA,6BAyKA;AACA;AAAA;AAAA;AACA,KA3KA;AA6KAC,gBA7KA,0BA6KA;AACA;AACA;AACA;;AACA;AACA,KAlLA;AAoLAC,mBApLA,6BAoLA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA,KA1LA;AA4LAC,iBA5LA,2BA4LA;AACA;AACA,KA9LA;AAgMAC,yBAhMA,mCAgMA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACAC;AACA;;AACA;AACAC;AACA;;AAEA;AACA;AAAA;AAAA;;AACA;AACAC;AACA;AACA;AACA,SArBA,MAqBA;AACA;AACAzE;AACA,WAFA,MAEA;AACAA;AACA;;AACA;AAAA;AAAA;;AACA;AACAyE;AACA;AACA;AACA,OAjCA;AAkCAA;AAAA;AAAA;AACA;AACA,KAzOA;AA2OAC,uBA3OA,iCA2OA;AACA;AACA;AAAA;AAAA,OAFA,CAGA;;;AACA;AACA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;;AACA;AACA,SAPA;AAQA;AACA,OAdA,CAeA;;;AACA;AACA,KA5PA;AA8PAC,kBA9PA,4BA8PA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AACAC;AACA;AACA;AACA;AACA,WAJA;AAKA;;AACA;AACA;AACAA;AACA;;AACA;AACA;;AACAA;AACA;AACA,SAFA;;AAGA;AACA;AACAA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AACA,KA5RA;AA8RAC,OA9RA,iBA8RA;AACA;AACAC;AADA;AAGA;;AAEA;AACA;AACAC;AAAA;AAAA;AACAA;AAAA;AAAA;AACA,OAJA,MAIA;AACAA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACA,KAhTA;AAkTAC,mBAlTA,6BAkTA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA,KAtTA;AAwTAC,mBAxTA,6BAwTA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA,KA5TA;AA8TAC,iBA9TA,2BA8TA;AACA;AACA,KAhUA;AAiUAC,mBAjUA,6BAiUA;AACA;AACA,KAnUA;AAoUAC,mBApUA,6BAoUA;AACA;AACA,KAtUA;AAuUAC,gBAvUA,0BAuUA;AACA;AACA,KAzUA;AA2UAC,mBA3UA,6BA2UA;AACA;AAAA;AAAA;;AACA;AACAC;AADA;AAGA,KAhVA;AAkVAC,kBAlVA,4BAkVA;AACA;AACA,KApVA;AAsVAC,eAtVA,yBAsVA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AAEA;;AAPA,iDAQAC,cARA;AAAA;;AAAA;AAQA;AAAA;AACA;AACA;AACAC,gCADA;AAEAC,2BAFA;AAGA3F,6CAHA;AAIA4F,+CAJA;AAKAC;AALA;AAOAL;AACA;AAlBA;AAAA;AAAA;AAAA;AAAA;;AAmBA;AACA,KA1WA;AA4WAM,qBA5WA,+BA4WA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA,KA/WA;AAiXAC,kBAjXA,4BAiXA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACAJ,4BADA;AAEA3F,0BAFA;AAGAsE,4BAHA;AAIAC;AAJA;AAMA,SAPA;AAQA;;AACA;AACA;AACA;AACA,4BADA,CAEA;;AACA;AACA;AACA;AACAyB;AACA,WAHA,MAGA;AACAA;AACA,WANA,CAOA;;AACA,SARA,MAQA;AACAA;AACA;;AACArB;AACAgB,0BADA;AAEA3F,wBAFA;AAGAsE,yCAHA;AAIAC;AAJA;;AAMA;AACA0B;AACA;AACA,OAvBA;AAwBA;AACA,KAxZA;AA0ZAC,iBA1ZA,2BA0ZA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;;AACA;AACApB;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACAA;AACA;;AACA;AACA;AACA;;AACA;AACA,KA/aA;AAibAqB,mBAjbA,6BAibA;AACA;AACA,KAnbA;AAqbAC,wBArbA,kCAqbA;AACA;AACA,KAvbA;AAybAC,oBAzbA,8BAybA;AACA;AACA;AACA;;AACA;AACA;AA9bA,GAzFA;AA0hBAC;AACA,iBADA,sBACAC,QADA,EACA;AACA;AACA,KAHA;AAIA,yBAJA,8BAIAC,UAJA,EAIA;AACA;AACA,KANA;AAOA,yBAPA,8BAOAA,UAPA,EAOA;AACA;AACA,KATA;AAUAzG;AACA0G,gBADA;AAEAC,aAFA,qBAEA;AACA;AACA;AAJA,KAVA;AAgBA7C,eAhBA,yBAgBA;AACA;AACA,KAlBA;AAmBA1D,YAnBA,oBAmBAwG,UAnBA,EAmBA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA,KA7BA;AA8BA,0BA9BA,+BA8BAC,SA9BA,EA8BAC,SA9BA,EA8BA;AACA;AACA;AACA,OAFA,MAEA;AACA;AACA;AACA;AApCA,GA1hBA;AAikBAC;AACAC,eADA,uBACApB,KADA,EACAqB,CADA,EACA;AACA;AAAA;AAAA;;AACAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AApBA;AAsBA,KA1BA;AA4BAC,sBA5BA,8BA4BAC,WA5BA,EA4BA1D,YA5BA,EA4BA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA,KApCA;AAsCA2D,gBAtCA,wBAsCAC,SAtCA,EAsCA;AAAA;;AACAA;AAEA;AACA;AACA;AACA,2EANA,CAQA;;AACA;AACA;AACA;AACA;;AACAhF;AACAC;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA,OAFA;AAGA,KAjEA;AAmEAgF,mBAnEA,6BAmEA;AACA;AACA;;AACA;AACA;AACAzF;AACA,SAFA,MAEA;AACAA;AACA;AACA;;AACA;AACA,KA9EA;AAgFA0F,cAhFA,sBAgFAC,QAhFA,EAgFAC,QAhFA,EAgFA;AACA;AAAA;AAAA;;AAEA;AACAA;AAEA;;AACA;AACA1C;AACA;;AACA2C;AACA,KA3FA;AA6FAC,iBA7FA,2BA6FA;AACA;AACA,KA/FA;AAiGAC,cAjGA,wBAiGA;AACA;AACA;AACA;AACA;;AACA;AACA,OALA,MAKA;AACA;AACA;AACA;;AACA;AACA;AACA,KA7GA;AA+GAC,oBA/GA,4BA+GAC,QA/GA,EA+GA;AAAA;;AACA;AACA,0CAFA,CAIA;;AACA;AACA;AACA;AACA;;AAEAC;AACA;;AACA;AACA;;AACA;AACAnG;AACA,SAJA,MAIA;AACA;AACA;AACA,OATA;AAUA;AACA,KApIA;AAsIAoG,sBAtIA,8BAsIAC,UAtIA,EAsIAC,WAtIA,EAsIA;AACA;AACA;AACA;AACA,KA1IA;AA4IAC,oBA5IA,4BA4IAC,WA5IA,EA4IA;AAAA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAfA,kDAiBA1C,cAjBA;AAAA;;AAAA;AAiBA;AAAA;AACA;AACAC,gCADA;AAEAC,6BAFA;AAGAyC;AAHA;AAKAC;AACA7C;AACA;AAzBA;AAAA;AAAA;AAAA;AAAA;;AAAA,kDA2BA8C,cA3BA;AAAA;;AAAA;AA2BA;AAAA;AACAD;AACA3C,gCADA;AAEAC;AAFA;AAIA;AAhCA;AAAA;AAAA;AAAA;AAAA;;AAkCA0C;AAAA;AAAA;AAEA;AACAA;AACA;AACA;AACAE;AACA,SAHA,MAGA;AACA;AACAA;AACA;AACA,OARA;AAUA,4CA/CA,CAiDA;;AACA;AACA;AACA;AACA;AACAC;AACA;AACA;AACA7G;AACA;AACA,SALA;AAMA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA,OAhBA,MAgBA;AACA;AACA;AACA;AACA;AACA,KAnNA;AAqNA8G,oBArNA,4BAqNAC,YArNA,EAqNAC,OArNA,EAqNA;AACA;AACA;AACA;;AACA;AACAC;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACAlD;AACA;AACA,WAJA,MAIA;AACA;AACAA;AACAmD;AACAC,sCADA;AAEAC;AAFA;AAIA;;AACAjE;AACA,kCADA;AAEAY;AAFA;AAIA,SAnBA;AAoBA;;AACA;AACA,KAhPA;AAkPAsD,qBAlPA,+BAkPA;AAAA;;AACA;AACA;AACArH;AACA,OAFA;AAGA;AACA,KAxPA;AA0PAsH,sBA1PA,8BA0PAC,WA1PA,EA0PAvD,KA1PA,EA0PA;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA,KAjQA;AAmQAwD,cAnQA,sBAmQAC,SAnQA,EAmQA;AAAA;;AACA;AAEA;AACA;AAEA,mBANA,CAQA;;AACA;AACAtB;AAAA;AAAA;AACAuB;AACAzG;AACAA,8CAJA,CAMA;AACA,OAPA,MAOA;AACA;;AACA;;AAEAkF;AACA;AACAlF;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7C;AACA,iBAFA,MAEA;AACAA;AACA,iBAFA,MAEA;AACAA;AACA;AACA,eARA,MAQA;AACA;AACAA;AACA,iBAFA,MAEA;AACAA;AACA;AACA;;AACA6C;AACA;;AACA;AACA;AACA;AACA;AACA7C;AACA4C,sCAFA,CAGA;AACA,eAJA,MAIA;AACA;AACAA;AACA5C;AACA,iBAHA,MAGA;AACA4C;AACA5C;AACA;AACA;;AACA6C;AACAA;AACAA;AACA;AAzCA;AA2CA,SAnDA;AAoDA;;AAEAA;AACAA;AACAA;AACAA;AAEA,mCA/EA,CAiFA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KA9VA;AAgWA0G,eAhWA,yBAgWA;AACA;AACA;AACA;;AACA;AACA5H,yDADA;AAEAmC;AAFA;AAIA,KAxWA;AA0WA0F,iBA1WA,2BA0WA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAFA,MAEA;AACA;AACA;AACA;AACAC;AACA7H;AACA,SAFA;AAGA;AACA;;AAEA;AACA,KAjYA;AAmYA8H,qBAnYA,6BAmYA1J,KAnYA,EAmYA;AACA;;AACA;AACA;AACA;;AACA;AACA,KAzYA;AA2YA2J,cA3YA,sBA2YA1J,IA3YA,EA2YAD,KA3YA,EA2YA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AAfA;AAiBA,KA9ZA;AAgaA4J,kBAhaA,0BAgaA5J,KAhaA,EAgaA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA,SAFA,MAEA;AACA;AACA;AACA;AACA,OATA,CAUA;;;AACA,UACA,qDACA,YADA,IACA,qCAFA,EAGA;AACA;AACA;;AACA;AACA,KAlbA;AAobA6J,iBApbA,yBAobAC,OApbA,EAobA9J,KApbA,EAobA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA,KAxbA;AA0bA+J,mBA1bA,2BA0bAC,QA1bA,EA0bAF,OA1bA,EA0bA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACAE;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AAAA;AAAA;;AACAC;;AACA;AACAxF;AACA;AACA;AACA,SAbA,MAaA;AACA;AAAA;AAAA;;AACAwF;;AACA;AACAxF;AACA;AACA;AACA,OArBA;AAsBAA;AAAA;AAAA,SA1BA,CA2BA;;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA;AACA;;AACA;AACA,KAleA;AAoeAyF,qBApeA,+BAoeA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAhfA;AAkfAC,qBAlfA,+BAkfA;AACA;AACA;AACA;;AACA;AACA,KAvfA;AAyfAC,kBAzfA,0BAyfAd,QAzfA,EAyfA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA,KAjgBA;AAmgBAe,gBAngBA,0BAmgBA;AAAA;;AACA;AAAA;AAAA;;AACA;;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA,SAPA,CAQA;;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WALA;AAMA;AACA,OApBA,MAoBA;AACA;AACA;AACA,SAFA,MAEA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA,KA9iBA;AAgjBAC,oBAhjBA,4BAgjBAC,MAhjBA,EAgjBA;AAAA;;AACA;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA,OAjBA,MAiBA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA,KAzkBA;AA2kBAC,wBA3kBA,kCA2kBA;AACA;AACA;;AACA;AACAC;AACAC;AACA;AACAC;AACA;AACA,KAplBA;AAslBAC,qBAtlBA,+BAslBA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;;AACA;AACAF;AACAA;AACA,SAHA,MAGA;AACAA;AACAA;AACA;;AACAA;AACA;AACA,KArmBA;AAumBAG,0BAvmBA,oCAumBA;AACA;AACA;;AACA;AACAF;AACA;;AACA;AACAD;AACAA;AACAA;AACAA;AACA;AACA;;AACAD;AACA,KArnBA;AAunBAK,aAvnBA,uBAunBA;AACA;AACA;AACA;AACA;AACA,KA5nBA;AA8nBAC,UA9nBA,kBA8nBA9K,IA9nBA,EA8nBAD,KA9nBA,EA8nBA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA,KAroBA;AAuoBAgL,aAvoBA,uBAuoBA;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KArpBA;AAupBA;AACA;AACA;AAEAC,sBA3pBA,gCA2pBA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA,SAFA;AAGA,OAJA,MAIA;AACA;AACA;AACA;;AACA;AACA,SAHA;AAIA;AACA,KAxqBA;AA0qBAC,oBA1qBA,4BA0qBAC,MA1qBA,EA0qBA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AACAC;AACA,OAFA,MAEA;AACAA;AACA;;AACA;;AACA;AACA;AACAC;AACA;;AACA;AACAD;;AACA;AACAC;AACA;AACA;AACA,KA7rBA;AA+rBAC,0BA/rBA,oCA+rBA;AAAA;;AACA;AAAA;AAAA;;AACA;AACA;AACA,OAFA;AAGA,KApsBA;AAssBA;AACA;AACA;AAEAC,WA1sBA,qBA0sBA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA,KAltBA;AAotBAC,WAptBA,qBAotBA;AACA;AAAA;AAAA;;AACAf;AACA;AACA;;AACA;AACAgB;AACA;AACA,KA5tBA;AA8tBAC,gBA9tBA,0BA8tBA;AAAA;;AACA;AAAA;AAAA;;AACA;AACAjB;AACA;AACAA;;AACA;AACA,OAHA,EAGA,mBAHA;AAIA,KAtuBA;AAwuBAkB,UAxuBA,oBAwuBA;AACA;AACA;AACA;AACA,KA5uBA;AA8uBAC,gBA9uBA,0BA8uBA;AACA;AAAA;AAAA;;AACAnB;;AACA;AACA;AACA;AACA,KApvBA;AAsvBAoB,SAtvBA,iBAsvBAV,MAtvBA,EAsvBAnL,KAtvBA,EAsvBA8L,GAtvBA,EAsvBA;AACA;AACA;;AACA;AAAA;AAAA;;AACA,mEAHA,CAIA;;AACA;AACAA,+BADA,CAEA;;AACA;AACA;AACA;AACA;AACA;AACA,KApwBA;AAswBAC,mBAtwBA,2BAswBAZ,MAtwBA,EAswBA;AACA;;AACA;AACA;AACA;;AACA;AACA,KA5wBA;AA8wBAa,mBA9wBA,2BA8wBAb,MA9wBA,EA8wBA;AACA;;AACA;AACA;AACA;;AACA;AACA,KApxBA;AAsxBAc,qBAtxBA,6BAsxBAd,MAtxBA,EAsxBAe,OAtxBA,EAsxBA;AAAA;AACA;AACA;AACA;AACA,OAFA,EAFA,CAMA;;AACA;AACA;AACA,OATA,CAUA;;;AACA;AACA;AACA,OAbA,CAcA;;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA,KA7yBA;AA+yBAC,YA/yBA,oBA+yBAhB,MA/yBA,EA+yBAe,OA/yBA,EA+yBA;AAAA;AACA;;AACA;AACA;AACA;AACA,KApzBA;AAszBAE,YAtzBA,oBAszBAjB,MAtzBA,EAszBAe,OAtzBA,EAszBA;AAAA;AACA;;AACA;AACA;AACA;AACA,KA3zBA;AA6zBAG,qBA7zBA,6BA6zBAC,aA7zBA,EA6zBA;AAAA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA,OALA,MAKA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA,KA30BA;AA60BAC,4BA70BA,oCA60BAD,aA70BA,EA60BA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;AACA,KAp1BA;AAs1BAE,6BAt1BA,qCAs1BAF,aAt1BA,EAs1BA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;AACA,KA71BA;AA+1BAG,gBA/1BA,wBA+1BAH,aA/1BA,EA+1BA;AACA;;AACA;AACAI;AACA;AACA,KAp2BA;AAs2BAC,iBAt2BA,yBAs2BAL,aAt2BA,EAs2BA;AACA;;AACA;AACAI;AACA;AACA,KA32BA;AA62BA;AACA;AACA;AAEAE,eAj3BA,yBAi3BA;AAAA;;AACA;AAAA;AAAA;;AACAnC;AACA;AACAA;;AACA;AACA;;AACA;AACA;AACA,OANA,EAMA,EANA;AAOA,KA33BA;AA63BAoC,kBA73BA,0BA63BAf,GA73BA,EA63BA;AACA;AACA;AACAA;AACAA;AACA;AACA,OANA,CAOA;;;AACA;AACAA;AACA,oCAFA,CAGA;AACA,OAJA,MAIA;AACAA;AACA,0CAFA,CAGA;AACA,OAJA,MAIA;AACAA;AACA;AACA,+BAHA,CAIA;AACA,OALA,MAKA;AACAA;AACA;AACA,yBAHA,CAIA;AACA,OALA,MAKA;AACA;AACA,6BAFA,CAGA;AACA,OAJA,MAIA;AACAA;AACA;AACA,0BAHA,CAIA;AACA,OALA,MAKA;AACAA;AACA;AACA,KAn6BA;AAq6BAgB,qBAr6BA,6BAq6BAhB,GAr6BA,EAq6BA;AACAA;AACAA;AACA;AACA;AACA,KA16BA;AA46BAiB,mBA56BA,2BA46BAjB,GA56BA,EA46BA;AAAA;;AACAA;AACAA;AAEA;AACA;;AACA;AACAkB;AACA;;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;;AACA;AACAC;AACA;;AACA;;AACA;AACA;AACA,OATA;AAUA;AACA,KAt8BA;AAw8BAC,gBAx8BA,wBAw8BApB,GAx8BA,EAw8BA;AACAA;AACA;;AACA;AACA;AACA;;AACA;AAAA;AAAA,OANA,CAQA;;;AACA;AACAqB;AACA;;AAEA;AACA;AACA,OAFA,MAEA;AACA;AACA;AACA;AACA;AACA,KA59BA;AA89BAC,gBA99BA,wBA89BAtB,GA99BA,EA89BA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA,SAFA,MAEA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA,OAdA,MAcA;AACA;AACA,OAFA,MAEA;AACA;AACA;AACA,KAn/BA;AAq/BAuB,cAr/BA,sBAq/BAvB,GAr/BA,EAq/BA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AACAA;AACA;AACA;AACA,OATA,MASA;AACA;AAAA;AAAA;;AACAA;;AACA;AACA;AACA;;AACA;AACAT;AACA;AACA;AACA;AACA,KA1gCA;AA4gCAiC,iBA5gCA,yBA4gCAC,OA5gCA,EA4gCA;AAAA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA,KAlhCA;AAohCAC,mBAphCA,6BAohCA;AACA/C;AACA;AACA,KAvhCA;AAyhCAgD,sBAzhCA,gCAyhCA;AAAA;;AACAhD;AACA;AACA;AACA,OAFA,EAEA,4BAFA;AAGA,KA9hCA;AAgiCAiD,cAhiCA,sBAgiCA1N,KAhiCA,EAgiCA;AACAA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AAEA;;AACA;AACA;AACA2N;AACA,SAFA,MAEA;AACAA;AACA;;AACA;AACAA;AACA;AACA,OATA,MASA;AACA;AACAA;AACA,SAFA,MAEA;AACA;;AACA;AACAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA,SAFA,MAEA;AACA;AACA;AACA;AACA,KAxkCA;AA0kCA;AACAC,YA3kCA,sBA2kCA;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;AACA,KAjlCA;AAmlCAC,wBAnlCA,gCAmlCAC,QAnlCA,EAmlCA;AACA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;;AACA;;AACA;AACAC;AACAC;AACA,SAHA,MAGA;AACA;AACA;AACA;;AACAA;AACAD;AACA;AACA;;AACA;AACA,KAzmCA;AA2mCAE,yBA3mCA,mCA2mCA;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AACA,OAFA,MAEA;AACA;AACA;;AACA;AACA,KApnCA;AAsnCAC,sBAtnCA,8BAsnCAC,YAtnCA,EAsnCA;AAAA;;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA,SAFA,MAEA;AACA;AACA;AACA;AACA,OAPA;AAQA;;AACA;AACAC;AACA,OAFA,MAEA;AACAA;AACA,OAFA,MAEA;AACAA;AACA;;AACA;AACA;AACA,KAnpCA;AAqpCAC,4BArpCA,oCAqpCAlD,MArpCA,EAqpCAgD,YArpCA,EAqpCA;AAAA;;AACA;AACA;AACA,OAFA,MAEA;AACA;;AACA;AACA;AACA;AACA;AACA,KA9pCA;AAgqCAG,8BAhqCA,sCAgqCAxE,OAhqCA,EAgqCAyE,UAhqCA,EAgqCA;AACA;AAAA;AAAA,OADA,CAEA;;;AACA;AACA;AACA,KArqCA;AAuqCAC,iBAvqCA,yBAuqCApC,QAvqCA,EAuqCA;AACA;AACA;AACA;AACA;AACA;AACA,OALA,MAKA;AACA;AACA;AACA,KAhrCA;AAkrCAqC,6BAlrCA,2CAkrCA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,OAFA;AAGAhE;AACA;AACAA,oDADA,CAEA;;AACA;AACA;AACA;AACA,OANA,EAMA,EANA;AAOA,KA9rCA;AAgsCAiE,0BAhsCA,kCAgsCAnK,KAhsCA,EAgsCAC,GAhsCA,EAgsCA;AACA;AACA;AACA;AACA,KApsCA;AAssCAmK,wBAtsCA,kCAssCA;AACA;AACA,KAxsCA;AA0sCAC,mBA1sCA,6BA0sCA;AACA;AACA;AACA,KA7sCA;AA+sCAC,cA/sCA,wBA+sCA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;;AACA;AACA;AACA;AACA;AACA,KAxtCA;AA0tCAC,kBA1tCA,0BA0tCAC,MA1tCA,EA0tCA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA,KA7uCA;AA+uCAC,mBA/uCA,2BA+uCAC,SA/uCA,EA+uCA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA,KAxvCA;AA0vCAC,wBA1vCA,gCA0vCAC,WA1vCA,EA0vCA;AACA;AACA;AACA,OAFA,MAEA;AACA;AACA;;AACA;AACA,KAjwCA;AAmwCAC,sBAnwCA,gCAmwCA;AACA;AAAA;AAAA;;AACA;;AACA;AACAC;;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACAC;AACA,OAHA,MAGA;AACA;AACA;AACAA;AACA;;AACA;AACA,KAvxCA;AAyxCA;AACA;AACA;AAEAC,cA7xCA,sBA6xCAvP,KA7xCA,EA6xCA;AACA;AACA,KA/xCA;AAiyCAwP,iBAjyCA,yBAiyCAxP,KAjyCA,EAiyCA;AACA;AACA,KAnyCA;AAqyCAyP,YAryCA,oBAqyCAzP,KAryCA,EAqyCA;AACA;AACA,KAvyCA;AAyyCA0P,eAzyCA,uBAyyCAzP,IAzyCA,EAyyCA;AACA;AACA,KA3yCA;AA6yCA0P,iBA7yCA,yBA6yCArG,QA7yCA,EA6yCA;AACA;AACA,KA/yCA;AAizCAsG,iBAjzCA,yBAizCAhK,KAjzCA,EAizCA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AA1BA;AA4BA,KA90CA;AAg1CAiK,gBAh1CA,wBAg1CAC,WAh1CA,EAg1CAC,SAh1CA,EAg1CA;AACA;AACA,KAl1CA;AAo1CAC,gBAp1CA,wBAo1CAF,WAp1CA,EAo1CAC,SAp1CA,EAo1CA;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;AACA,KAz1CA;AA21CAE,kBA31CA,0BA21CAH,WA31CA,EA21CAvB,UA31CA,EA21CA;AACA;AACA;AACA;;AACA;AACA,KAh2CA;AAk2CA2B,gBAl2CA,wBAk2CAtK,KAl2CA,EAk2CA;AACA;AACA,KAp2CA;AAs2CAuK,kBAt2CA,0BAs2CAlQ,IAt2CA,EAs2CA;AACA;AACA,KAx2CA;AA02CAmQ,oBA12CA,4BA02CAnQ,IA12CA,EA02CA;AACA;AACA,KA52CA;AA82CAoQ,YA92CA,oBA82CAC,OA92CA,EA82CA;AAAA;;AACA;AAAA;AAAA;;AACA;;AACA;AACAC;AACA;;AACA;AACAA;AACA;;AACA;AACA;;AACA;AACAC;AACA,SAFA,MAEA;AACAA;AACA,SAFA,MAEA;AACAC;AACA;AACAD;AACA;AACA,WAJA;AAKA;;AAZA,oDAaAA,YAbA;AAAA;;AAAA;AAaA;AAAA;;AACA;AACAD;AACA;AACA;AAjBA;AAAA;AAAA;AAAA;AAAA;AAkBA;;AACA;;AACA;AACA9F;AACA,OAFA,MAEA;AACAA;AACA;AACA;AAh5CA,GAjkBA;AAo9DAiG,SAp9DA,qBAo9DA;AACAjG;AACAA;AACAA;AACA;AACA,GAz9DA;AA29DAkG,eA39DA,2BA29DA;AACAlG;AACAA;AACAA;AACA;AA/9DA","names":["HOUR_TOKENS","MINUTE_TOKENS","SECOND_TOKENS","APM_TOKENS","BASIC_TYPES","format","minuteInterval","secondInterval","hourRange","minuteRange","secondRange","hideDisabledHours","hideDisabledMinutes","hideDisabledSeconds","hideDisabledItems","hideDropdown","blurDelay","manualInputTimeout","dropOffsetHeight","name","props","value","type","default","hideClearButton","disabled","closeOnComplete","id","inputClass","placeholder","tabindex","inputWidth","autocomplete","hourLabel","minuteLabel","secondLabel","apmLabel","amText","pmText","advancedKeyboard","lazy","autoScroll","dropDirection","containerId","appendToBody","manualInput","fixedDropdownButton","debugMode","data","timeValue","hours","minutes","seconds","apms","isActive","showDropdown","isFocusing","debounceTimer","hourType","minuteType","secondType","apmType","hour","minute","second","apm","fullValues","bakDisplayTime","doClearApmChecking","selectionTimer","kbInputTimer","kbInputLog","bakCurrentPos","forceDropOnTop","computed","opts","options","useStringValue","formatString","inUse","typesInUse","types","tokens","displayTime","customDisplayTime","inputIsEmpty","allValueSelected","columnsSequence","showClearBtn","showDropdownBtn","baseOn12Hours","hourRangeIn24HrFormat","start","end","range","restrictedHourRange","validHoursList","list","has","customApmText","result","minuteRangeList","secondRangeList","hourLabelText","minuteLabelText","secondLabelText","apmLabelText","inputWidthStyle","width","tokenRegexBase","tokenChunks","tokensMatchAll","index","token","needsCalibrate","len","needsPosCalibrate","tokenChunksPos","chunkCurrentLen","calibrateLen","invalidValues","hasInvalidInput","autoDirectionEnabled","dropdownDirClass","watch","newValue","newInteval","deep","handler","toDisabled","newLength","oldLength","methods","formatValue","i","checkAcceptingType","validValues","renderFormat","newFormat","renderHoursList","renderList","listType","interval","isMinute","renderApmList","readValues","readObjectValues","objValue","CONFIG","getMatchAllByRegex","testString","regexString","readStringValues","stringValue","isValueToken","chunks","othersMatchAll","regexCombo","valueResults","polyfillMatchAll","targetString","regxStr","matchesList","indicesReg","str","regex","addFallbackValues","setValueFromString","parsedValue","fillValues","forceEmit","apmValue","getFullData","emitTimeValue","tokensInUse","translate12hRange","isDisabled","isDisabledHour","notInInterval","section","renderRangeList","rawRange","formatedValue","forceApmSelection","emptyApmSelection","apmDisplayText","toggleActive","setDropdownState","toShow","appendDropdownToBody","window","dropdown","body","updateDropdownPos","removeDropdownFromBody","blurEvent","select","clearTime","checkForAutoScroll","scrollToSelected","column","targetList","targetValue","scrollToSelectedValues","onFocus","escBlur","inputBox","debounceBlur","onBlur","keepFocusing","onTab","evt","validItemsInCol","activeItemInCol","getClosestSibling","dataKey","prevItem","nextItem","getSideColumnName","currentColumn","getFirstItemInSideColumn","getActiveItemInSideColumn","toLeftColumn","targetItem","toRightColumn","onMouseDown","keyDownHandler","onCompostionStart","onCompostionEnd","inputIsCustomApmText","bakPos","pasteHandler","pastingText","arrowHandler","tabHandler","keyboardInput","newChar","clearKbInputLog","debounceClearKbLog","setKbInput","validValue","onChange","getNearestChunkByPos","startPos","nearest","nearestDelta","selectFirstValidValue","getClosestHourItem","currentValue","nextIndex","getClosestValidItemInCol","setSanitizedValueToSection","inputValue","setManualHour","debounceSetInputSelection","setInputSelectionRange","getCurrentTokenChunk","selectFirstSlot","toNextSlot","toLateralToken","toLeft","isCustomApmText","inputData","replaceCustomApmText","inputString","checkDropDirection","container","spaceDown","is12hRange","match12hRange","isNumber","isBasicType","lowerCasedApm","getTokenRegex","isEmptyValue","targetToken","testValue","isValidValue","sanitizedValue","getTokenType","getTokenByType","isMinuteOrSecond","debugLog","logText","identifier","inputClasses","Object","mounted","beforeDestroy"],"sourceRoot":"node_modules/vue2-timepicker/src","sources":["vue-timepicker.vue"],"sourcesContent":["<script>\nconst CONFIG = {\n  HOUR_TOKENS: ['HH', 'H', 'hh', 'h', 'kk', 'k'],\n  MINUTE_TOKENS: ['mm', 'm'],\n  SECOND_TOKENS: ['ss', 's'],\n  APM_TOKENS: ['A', 'a'],\n  BASIC_TYPES: ['hour', 'minute', 'second', 'apm']\n}\n\nconst DEFAULT_OPTIONS = {\n  format: 'HH:mm',\n  minuteInterval: 1,\n  secondInterval: 1,\n  hourRange: null,\n  minuteRange: null,\n  secondRange: null,\n  hideDisabledHours: false,\n  hideDisabledMinutes: false,\n  hideDisabledSeconds: false,\n  hideDisabledItems: false,\n  hideDropdown: false,\n  blurDelay: 300,\n  manualInputTimeout: 1000,\n  dropOffsetHeight: 160\n}\n\nexport default {\n  name: 'VueTimepicker',\n  props: {\n    value: { type: [ Object, String ] },\n    format: { type: String },\n    minuteInterval: { type: [ Number, String ] },\n    secondInterval: { type: [ Number, String ] },\n\n    hourRange: { type: Array },\n    minuteRange: { type: Array },\n    secondRange: { type: Array },\n\n    hideDisabledHours: { type: Boolean, default: false },\n    hideDisabledMinutes: { type: Boolean, default: false },\n    hideDisabledSeconds: { type: Boolean, default: false },\n    hideDisabledItems: { type: Boolean, default: false },\n\n    hideClearButton: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    closeOnComplete: { type: Boolean, default: false },\n\n    id: { type: String },\n    name: { type: String },\n    inputClass: { type: [ String, Object, Array ] },\n    placeholder: { type: String },\n    tabindex: { type: [ Number, String ], default: 0 },\n    inputWidth: { type: String },\n    autocomplete: { type: String, default: 'off' },\n\n    hourLabel: { type: String },\n    minuteLabel: { type: String },\n    secondLabel: { type: String },\n    apmLabel: { type: String },\n    amText: { type: String },\n    pmText: { type: String },\n\n    blurDelay: { type: [ Number, String ] },\n    advancedKeyboard: { type: Boolean, default: false },\n\n    lazy: { type: Boolean, default: false },\n    autoScroll: { type: Boolean, default: false },\n\n    dropDirection: { type: String, default: 'down' },\n    dropOffsetHeight: { type: [ Number, String ] },\n    containerId: { type: String },\n    appendToBody: { type: Boolean, default: false },\n\n    manualInput: { type: Boolean, default: false },\n    manualInputTimeout: { type: [ Number, String ] },\n    hideDropdown: { type: Boolean, default: false },\n    fixedDropdownButton: { type: Boolean, default: false },\n\n    debugMode: { type: Boolean, default: false }\n  },\n\n  data () {\n    return {\n      timeValue: {},\n\n      hours: [],\n      minutes: [],\n      seconds: [],\n      apms: [],\n\n      isActive: false,\n      showDropdown: false,\n      isFocusing: false,\n      debounceTimer: undefined,\n\n      hourType: 'HH',\n      minuteType: 'mm',\n      secondType: '',\n      apmType: '',\n      hour: '',\n      minute: '',\n      second: '',\n      apm: '',\n      fullValues: undefined,\n      bakDisplayTime: undefined,\n      doClearApmChecking: false,\n\n      selectionTimer: undefined,\n      kbInputTimer: undefined,\n      kbInputLog: '',\n      bakCurrentPos: undefined,\n      forceDropOnTop: false\n    }\n  },\n\n  computed: {\n    opts () {\n      const options = Object.assign({}, DEFAULT_OPTIONS)\n\n      if (this.format && this.format.length) {\n        options.format = String(this.format)\n      }\n\n      if (this.isNumber(this.minuteInterval)) {\n        options.minuteInterval = +this.minuteInterval\n      }\n      // minuteInterval failsafe\n      if (!options.minuteInterval || options.minuteInterval < 1 || options.minuteInterval > 60) {\n        if (this.debugMode) {\n          if (options.minuteInterval > 60) {\n            this.debugLog(`\"minute-interval\" should be less than 60. Current value is ${this.minuteInterval}`)\n          } else if (options.minuteInterval === 0 || options.minuteInterval < 1) {\n            this.debugLog(`\"minute-interval\" should be NO less than 1. Current value is ${this.minuteInterval}`)\n          }\n        }\n        if (options.minuteInterval === 0) {\n          options.minuteInterval = 60\n        } else {\n          options.minuteInterval = 1\n        }\n      }\n\n      if (this.isNumber(this.secondInterval)) {\n        options.secondInterval = +this.secondInterval\n      }\n      // secondInterval failsafe\n      if (!options.secondInterval || options.secondInterval < 1 || options.secondInterval > 60) {\n        if (this.debugMode) {\n          if (options.secondInterval > 60) {\n            this.debugLog(`\"second-interval\" should be less than 60. Current value is ${this.secondInterval}`)\n          } else if (options.secondInterval === 0 || options.secondInterval < 1) {\n            this.debugLog(`\"second-interval\" should be NO less than 1. Current value is ${this.secondInterval}`)\n          }\n        }\n        if (options.secondInterval === 0) {\n          options.secondInterval = 60\n        } else {\n          options.secondInterval = 1\n        }\n      }\n\n      if (this.hourRange && Array.isArray(this.hourRange)) {\n        options.hourRange = JSON.parse(JSON.stringify(this.hourRange))\n        if (!this.hourRange.length && this.debugMode) {\n          this.debugLog('The \"hour-range\" array is empty (length === 0)')\n        }\n      }\n\n      if (this.minuteRange && Array.isArray(this.minuteRange)) {\n        options.minuteRange = JSON.parse(JSON.stringify(this.minuteRange))\n        if (!this.minuteRange.length && this.debugMode) {\n          this.debugLog('The \"minute-range\" array is empty (length === 0)')\n        }\n      }\n\n      if (this.secondRange && Array.isArray(this.secondRange)) {\n        options.secondRange = JSON.parse(JSON.stringify(this.secondRange))\n        if (!this.secondRange.length && this.debugMode) {\n          this.debugLog('The \"second-range\" array is empty (length === 0)')\n        }\n      }\n\n      if (this.hideDisabledItems) {\n        options.hideDisabledItems = true\n      }\n\n      if (this.hideDisabledHours || this.hideDisabledItems) {\n        options.hideDisabledHours = true\n      }\n      if (this.hideDisabledMinutes || this.hideDisabledItems) {\n        options.hideDisabledMinutes = true\n      }\n      if (this.hideDisabledSeconds || this.hideDisabledItems) {\n        options.hideDisabledSeconds = true\n      }\n\n      if (this.hideDropdown) {\n        if (this.manualInput) {\n          options.hideDropdown = true\n        } else if (this.debugMode) {\n          this.debugLog('\"hide-dropdown\" only works with \"manual-input\" mode')\n        }\n      }\n\n      if (this.blurDelay && +this.blurDelay > 0) {\n        options.blurDelay = +this.blurDelay\n      }\n\n      if (this.manualInputTimeout && +this.manualInputTimeout > 0) {\n        options.manualInputTimeout = +this.manualInputTimeout\n      }\n\n      if (this.dropOffsetHeight && +this.dropOffsetHeight > 0) {\n        options.dropOffsetHeight = +this.dropOffsetHeight\n      }\n\n      return options\n    },\n\n    useStringValue () {\n      return typeof this.value === 'string'\n    },\n\n    formatString () {\n      return this.opts.format || DEFAULT_OPTIONS.format\n    },\n\n    inUse () {\n      const typesInUse = CONFIG.BASIC_TYPES.filter(type => this.getTokenByType(type))\n      // Sort types and tokens by their sequence in the \"format\" string\n      typesInUse.sort((l, r) => {\n        return this.formatString.indexOf(this.getTokenByType(l) || null) - this.formatString.indexOf(this.getTokenByType(r) || null)\n      })\n      const tokensInUse = typesInUse.map(type => this.getTokenByType(type))\n      return {\n        hour: !!this.hourType,\n        minute: !!this.minuteType,\n        second: !!this.secondType,\n        apm: !!this.apmType,\n        types: typesInUse || [],\n        tokens: tokensInUse || []\n      }\n    },\n\n    displayTime () {\n      let formatString = String(this.formatString)\n      if (this.hour) {\n        formatString = formatString.replace(new RegExp(this.hourType, 'g'), this.hour)\n      }\n      if (this.minute) {\n        formatString = formatString.replace(new RegExp(this.minuteType, 'g'), this.minute)\n      }\n      if (this.second && this.secondType) {\n        formatString = formatString.replace(new RegExp(this.secondType, 'g'), this.second)\n      }\n      if (this.apm && this.apmType) {\n        formatString = formatString.replace(new RegExp(this.apmType, 'g'), this.apm)\n      }\n      return formatString\n    },\n\n    customDisplayTime () {\n      if (!this.amText && !this.pmText) {\n        return this.displayTime\n      }\n      return this.displayTime.replace(new RegExp(this.apm, 'g'), this.apmDisplayText(this.apm))\n    },\n\n    inputIsEmpty () {\n      return this.formatString === this.displayTime\n    },\n\n    allValueSelected () {\n      if (\n        (this.inUse.hour && !this.hour) ||\n        (this.inUse.minute && !this.minute) ||\n        (this.inUse.second && !this.second) ||\n        (this.inUse.apm && !this.apm)\n      ) {\n        return false\n      }\n      return true\n    },\n\n    columnsSequence () {\n      return this.inUse.types.map(type => type) || []\n    },\n\n    showClearBtn () {\n      if (this.hideClearButton || this.disabled) {\n        return false\n      }\n      return !this.inputIsEmpty\n    },\n\n    showDropdownBtn () {\n      if (this.fixedDropdownButton) { return true }\n      if (this.opts.hideDropdown && this.isActive && !this.showDropdown) {\n        return true\n      }\n      return false\n    },\n\n    baseOn12Hours () {\n      return this.hourType === 'h' || this.hourType === 'hh'\n    },\n\n    hourRangeIn24HrFormat () {\n      if (!this.hourType || !this.opts.hourRange) { return false }\n      if (!this.opts.hourRange.length) { return [] }\n\n      const range = []\n      this.opts.hourRange.forEach(value => {\n        if (value instanceof Array) {\n          if (value.length > 2 && this.debugMode) {\n            this.debugLog(`Nested array within \"hour-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n          }\n\n          let start = value[0]\n          let end = value[1] || value[0]\n\n          if (this.is12hRange(start)) {\n            start = this.translate12hRange(start)\n          }\n          if (this.is12hRange(end)) {\n            end = this.translate12hRange(end)\n          }\n\n          for (let i = +start; i <= +end; i++) {\n            if (i < 0 || i > 24) { continue }\n            if (!range.includes(i)) {\n              range.push(i)\n            }\n          }\n        } else {\n          if (this.is12hRange(value)) {\n            value = this.translate12hRange(value)\n          } else {\n            value = +value\n          }\n          if (value < 0 || value > 24) { return }\n          if (!range.includes(value)) {\n            range.push(value)\n          }\n        }\n      })\n      range.sort((l, r) => { return l - r })\n      return range\n    },\n\n    restrictedHourRange () {\n      // No restriction\n      if (!this.hourRangeIn24HrFormat) { return false }\n      // 12-Hour\n      if (this.baseOn12Hours) {\n        const range = this.hourRangeIn24HrFormat.map((value) => {\n          if (value === 12) {\n            return '12p'\n          } else if (value === 24 || value === 0) {\n            return '12a'\n          }\n          return value > 12 ? `${value % 12}p` : `${value}a`\n        })\n        return range\n      }\n      // 24-Hour\n      return this.hourRangeIn24HrFormat\n    },\n\n    validHoursList () {\n      if (!this.manualInput) { return false }\n      if (this.restrictedHourRange) {\n        let list = []\n        if (this.baseOn12Hours) {\n          list = this.restrictedHourRange.map(hr => {\n            const l = hr.substr(0, hr.length - 1)\n            const r = hr.substr(-1)\n            return `${this.formatValue(this.hourType, l)}${r}`\n          })\n          const am12Index = list.indexOf('12a')\n          if (am12Index > 0) {\n            // Make '12a' the first item in h/hh\n            list.unshift(list.splice(am12Index, 1)[0])\n          }\n          return list\n        }\n        list = this.restrictedHourRange.map(hr => {\n          return this.formatValue(this.hourType, hr)\n        })\n        if (list.length > 1 && list[0] && list[0] === '24') {\n          // Make '24' the last item in k/kk\n          list.push(list.shift())\n        }\n        return list\n      }\n      if (this.baseOn12Hours) {\n        return [].concat([], this.hours.map(hr => `${hr}a`), this.hours.map(hr => `${hr}p`))\n      }\n      return this.hours\n    },\n\n    has () {\n      const result = {\n        customApmText: false\n      }\n      const apmEnabled = !!this.apmType\n\n      if (apmEnabled && this.hourRangeIn24HrFormat && this.hourRangeIn24HrFormat.length) {\n        const range = [].concat([], this.hourRangeIn24HrFormat)\n        result.am = range.some(value => value < 12 || value === 24)\n        result.pm = range.some(value => value >= 12 && value < 24)\n      } else {\n        result.am = apmEnabled\n        result.pm = apmEnabled\n      }\n      if ((this.amText && this.amText.length) || (this.pmText && this.pmText.length)) {\n        result.customApmText = true\n      }\n      return result\n    },\n\n    minuteRangeList () {\n      if (!this.minuteType || !this.opts.minuteRange) { return false }\n      if (!this.opts.minuteRange.length) { return [] }\n      return this.renderRangeList(this.opts.minuteRange, 'minute')\n    },\n\n    secondRangeList () {\n      if (!this.secondType || !this.opts.secondRange) { return false }\n      if (!this.opts.secondRange.length) { return [] }\n      return this.renderRangeList(this.opts.secondRange, 'second')\n    },\n    \n    hourLabelText () {\n      return this.hourLabel || this.hourType\n    },\n    minuteLabelText () {\n      return this.minuteLabel || this.minuteType\n    },\n    secondLabelText() {\n      return this.secondLabel || this.secondType\n    },\n    apmLabelText () {\n      return this.apmLabel || this.apmType\n    },\n\n    inputWidthStyle () {\n      if (!this.inputWidth || !this.inputWidth.length) { return }\n      return {\n        width: this.inputWidth\n      }\n    },\n\n    tokenRegexBase () {\n      return this.inUse.tokens.join('|')\n    },\n\n    tokenChunks () {\n      if (!this.manualInput && !this.useStringValue) { return false }\n\n      const formatString = String(this.formatString)\n      const tokensRegxStr = `(${this.tokenRegexBase})+?`\n      const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n\n      const tokenChunks = []\n      for (let tkMatch of tokensMatchAll) {\n        const rawToken = tkMatch[0]\n        const tokenMatchItem = {\n          index: tkMatch.index,\n          token: rawToken,\n          type: this.getTokenType(rawToken),\n          needsCalibrate: rawToken.length < 2,\n          len: (rawToken || '').length\n        }\n        tokenChunks.push(tokenMatchItem)\n      }\n      return tokenChunks\n    },\n\n    needsPosCalibrate () {\n      if (!this.manualInput) { return false }\n      return this.tokenChunks.some(chk => chk.needsCalibrate)\n    },\n\n    tokenChunksPos () {\n      if (!this.manualInput) { return false }\n      if (!this.needsPosCalibrate) {\n        return this.tokenChunks.map(chk => {\n          return {\n            token: chk.token,\n            type: chk.type,\n            start: chk.index,\n            end: chk.index + chk.len\n          }\n        })\n      }\n      const list = []\n      let calibrateLen = 0\n      this.tokenChunks.forEach(chk => {\n        let chunkCurrentLen\n        // Adjust for customized AM/PM text\n        if (chk.type === 'apm' && this.has.customApmText) {\n          if (this.apm && this.apm.length) {\n            const customApmText = this.apm.toLowerCase() === 'am' ? this.amText : this.pmText\n            chunkCurrentLen = (customApmText && customApmText.length) ? customApmText.length : chk.len\n          } else {\n            chunkCurrentLen = chk.len\n          }\n        // Others\n        } else {\n          chunkCurrentLen = this[chk.type] && this[chk.type].length ? this[chk.type].length : chk.len\n        }\n        list.push({\n          token: chk.token,\n          type: chk.type,\n          start: chk.index + calibrateLen,\n          end: chk.index + calibrateLen + chunkCurrentLen\n        })\n        if (chk.needsCalibrate && chunkCurrentLen > chk.len) {\n          calibrateLen += (chunkCurrentLen - chk.len)\n        }\n      })\n      return list\n    },\n\n    invalidValues () {\n      if (this.inputIsEmpty) { return [] }\n      if (!this.restrictedHourRange && !this.minuteRangeList && !this.secondRangeList && this.opts.minuteInterval === 1 && this.opts.secondInterval === 1) { return [] }\n\n      const result = []\n      if (this.inUse.hour && !this.isEmptyValue(this.hourType, this.hour) && (!this.isValidValue(this.hourType, this.hour) || this.isDisabled('hour', this.hour))) {\n        result.push('hour')\n      }\n      if (this.inUse.minute && !this.isEmptyValue(this.minuteType, this.minute) && (!this.isValidValue(this.minuteType, this.minute) || this.isDisabled('minute', this.minute) || this.notInInterval('minute', this.minute))) {\n        result.push('minute')\n      }\n      if (this.inUse.second && !this.isEmptyValue(this.secondType, this.second) && (!this.isValidValue(this.secondType, this.second) || this.isDisabled('second', this.second) || this.notInInterval('second', this.second))) {\n        result.push('second')\n      }\n      if (this.inUse.apm && !this.isEmptyValue(this.apmType, this.apm) && (!this.isValidValue(this.apmType, this.apm) || this.isDisabled('apm', this.apm))) {\n        result.push('apm')\n      }\n      if (result.length) {\n        return result\n      }\n      return []\n    },\n\n    hasInvalidInput () {\n      return Boolean(this.invalidValues && this.invalidValues.length)\n    },\n\n    autoDirectionEnabled () {\n      return this.dropDirection === 'auto'\n    },\n\n    dropdownDirClass () {\n      if (this.autoDirectionEnabled) {\n        return this.forceDropOnTop ? 'drop-up' : 'drop-down'\n      }\n      return this.dropDirection === 'up' ? 'drop-up' : 'drop-down'      \n    }\n  },\n\n  watch: {\n    'opts.format' (newValue) {\n      this.renderFormat(newValue)\n    },\n    'opts.minuteInterval' (newInteval) {\n      this.renderList('minute', newInteval)\n    },\n    'opts.secondInterval' (newInteval) {\n      this.renderList('second', newInteval)\n    },\n    value: {\n      deep: true,\n      handler () {\n        this.readValues()\n      }\n    },\n    displayTime () {\n      this.fillValues()\n    },\n    disabled (toDisabled) {\n      if (toDisabled) {\n        // Force close dropdown and reset status when disabled\n        if (this.isActive) {\n          this.isActive = false\n        }\n        if (this.showDropdown) {\n          this.showDropdown = false\n        }\n      }\n    },\n    'invalidValues.length' (newLength, oldLength) {\n      if (newLength && newLength >= 1) {\n        this.$emit('error', this.invalidValues)\n      } else if (oldLength && oldLength >= 1) {\n        this.$emit('error', [])\n      }\n    }\n  },\n\n  methods: {\n    formatValue (token, i) {\n      if (!this.isNumber(i)) { return '' }\n      i = +i\n      switch (token) {\n        case 'H':\n        case 'h':\n        case 'k':\n        case 'm':\n        case 's':\n          if (['h', 'k'].includes(token) && i === 0) {\n            return token === 'k' ? '24' : '12'\n          }\n          return String(i)\n        case 'HH':\n        case 'mm':\n        case 'ss':\n        case 'hh':\n        case 'kk':\n          if (['hh', 'kk'].includes(token) && i === 0) {\n            return token === 'kk' ? '24' : '12'\n          }\n          return i < 10 ? `0${i}` : String(i)\n        default:\n          return ''\n      }\n    },\n\n    checkAcceptingType (validValues, formatString) {\n      if (!validValues || !formatString || !formatString.length) { return '' }\n      for (let i = 0; i < validValues.length; i++) {\n        if (formatString.indexOf(validValues[i]) > -1) {\n          return validValues[i]\n        }\n      }\n      return ''\n    },\n\n    renderFormat (newFormat) {\n      newFormat = newFormat || this.opts.format || DEFAULT_OPTIONS.format\n\n      let hourType = this.checkAcceptingType(CONFIG.HOUR_TOKENS, newFormat)\n      let minuteType = this.checkAcceptingType(CONFIG.MINUTE_TOKENS, newFormat)\n      this.secondType = this.checkAcceptingType(CONFIG.SECOND_TOKENS, newFormat)\n      this.apmType = this.checkAcceptingType(CONFIG.APM_TOKENS, newFormat)\n\n      // Failsafe checking\n      if (!hourType && !minuteType && !this.secondType && !this.apmType) {\n        if (this.debugMode && this.format) {\n          this.debugLog(`No valid tokens found in your defined \"format\" string \"${this.format}\". Fallback to the default \"HH:mm\" format.`)\n        }\n        hourType = 'HH'\n        minuteType = 'mm'\n      }\n      this.hourType = hourType\n      this.minuteType = minuteType\n\n      this.hourType ? this.renderHoursList() : this.hours = []\n      this.minuteType ? this.renderList('minute') : this.minutes = []\n      this.secondType ? this.renderList('second') : this.seconds = []\n      this.apmType ? this.renderApmList() : this.apms = []\n\n      this.$nextTick(() => {\n        this.readValues()\n      })\n    },\n\n    renderHoursList () {\n      const hoursCount = this.baseOn12Hours ? 12 : 24\n      const hours = []\n      for (let i = 0; i < hoursCount; i++) {\n        if (this.hourType === 'k' || this.hourType === 'kk') {\n          hours.push(this.formatValue(this.hourType, i + 1))\n        } else {\n          hours.push(this.formatValue(this.hourType, i))\n        }\n      }\n      this.hours = hours\n    },\n\n    renderList (listType, interval) {\n      if (!this.isMinuteOrSecond(listType)) { return }\n\n      const isMinute = listType === 'minute'\n      interval = interval || (isMinute ? (this.opts.minuteInterval || DEFAULT_OPTIONS.minuteInterval) : (this.opts.secondInterval || DEFAULT_OPTIONS.secondInterval))\n\n      const result = []\n      for (let i = 0; i < 60; i += interval) {\n        result.push(this.formatValue(isMinute ? this.minuteType : this.secondType, i))\n      }\n      isMinute ? this.minutes = result : this.seconds = result\n    },\n\n    renderApmList () {\n      this.apms = this.apmType === 'A' ? ['AM', 'PM'] : ['am', 'pm']\n    },\n\n    readValues () {\n      if (this.useStringValue) {\n        if (this.debugMode) {\n          this.debugLog(`Received a string value: \"${this.value}\"`)\n        }\n        this.readStringValues(this.value)\n      } else {\n        if (this.debugMode) {\n          this.debugLog(`Received an object value: \"${JSON.stringify(this.value || {})}\"`)\n        }\n        this.readObjectValues(this.value)\n      }\n    },\n\n    readObjectValues (objValue) {\n      const timeValue = JSON.parse(JSON.stringify(objValue || {}))\n      const values = Object.keys(timeValue)\n\n      // Failsafe for empty `v-model` object\n      if (values.length === 0) {\n        this.addFallbackValues()\n        return\n      }\n\n      CONFIG.BASIC_TYPES.forEach(type => {\n        const token = this.getTokenByType(type)\n        if (values.indexOf(token) > -1) {\n          const sanitizedValue = this.sanitizedValue(token, timeValue[token])\n          this[type] = sanitizedValue\n          timeValue[token] = sanitizedValue\n        } else {\n          this[type] = ''\n        }\n      })\n      this.timeValue = timeValue\n    },\n\n    getMatchAllByRegex (testString, regexString) {\n      const str = 'polyfillTest'\n      const needsPolyfill = Boolean(!str.matchAll || typeof str.matchAll !== 'function')\n      return needsPolyfill ? this.polyfillMatchAll(testString, regexString) : testString.matchAll(new RegExp(regexString, 'g'))\n    },\n\n    readStringValues (stringValue) {\n      // Failsafe for empty `v-model` string\n      if (!stringValue || !stringValue.length) {\n        this.addFallbackValues()\n        return\n      }\n\n      const formatString = String(this.formatString)\n      const tokensRegxStr = `(${this.tokenRegexBase})+?`\n      const othersRegxStr = `[^(${this.tokenRegexBase})]+`\n\n      const tokensMatchAll = this.getMatchAllByRegex(formatString, tokensRegxStr)\n      const othersMatchAll = this.getMatchAllByRegex(formatString, othersRegxStr)\n\n      const chunks = []\n      const tokenChunks = []\n\n      for (let tkMatch of tokensMatchAll) {\n        const tokenMatchItem = {\n          index: tkMatch.index,\n          token: tkMatch[0],\n          isValueToken: true\n        }\n        chunks.push(tokenMatchItem)\n        tokenChunks.push(tokenMatchItem)\n      }\n\n      for (let otMatch of othersMatchAll) {\n        chunks.push({\n          index: otMatch.index,\n          token: otMatch[0]\n        })\n      }\n\n      chunks.sort((l, r) => l.index < r.index ? -1 : 1)\n\n      let regexCombo = ''\n      chunks.forEach(chunk => {\n        if (chunk.isValueToken) {\n          const tokenRegex = this.getTokenRegex(chunk.token) || ''\n          regexCombo += tokenRegex\n        } else {\n          const safeChars = chunk.token.replace(/\\\\{0}(\\*|\\?|\\.|\\+)/g, '\\\\$1')\n          regexCombo += `(?:${safeChars})`\n        }\n      })\n\n      const comboReg = new RegExp(regexCombo)\n\n      // Do test before match\n      if (comboReg.test(stringValue)) {\n        const matchResults = stringValue.match(new RegExp(regexCombo))\n        const valueResults = matchResults.slice(1, tokenChunks.length + 1)\n        const timeValue = {}\n        valueResults.forEach((value, vrIndex) => {\n          if (tokenChunks[vrIndex]) {\n            const targetToken = tokenChunks[vrIndex].token\n            timeValue[targetToken] = this.setValueFromString(value, targetToken)\n          }\n        })\n        this.timeValue = timeValue\n\n        if (this.debugMode) {\n          const tokenChunksForLog = tokenChunks.map(tChunk => tChunk && tChunk.token)\n          this.debugLog(`Successfully parsed values ${JSON.stringify(valueResults)}\\nfor ${JSON.stringify(tokenChunksForLog)}\\nin format pattern '${this.formatString}'`)\n        }\n      } else {\n        if (this.debugMode) {\n          this.debugLog(`The input string in \"v-model\" does NOT match the \"format\" pattern\\nformat: ${this.formatString}\\nv-model: ${stringValue}`)\n        }\n      }\n    },\n\n    polyfillMatchAll (targetString, regxStr) {\n      const matchesList = targetString.match(new RegExp(regxStr, 'g'))\n      const result = []\n      const indicesReg = []\n      if (matchesList && matchesList.length) {\n        matchesList.forEach(matchedItem => {\n          const existIndex = indicesReg.findIndex(idxItem => idxItem.str === matchedItem)\n          let index\n          if (existIndex >= 0) {\n            if (indicesReg[existIndex] && indicesReg[existIndex].regex) {\n              index = indicesReg[existIndex].regex.exec(targetString).index\n            }\n          } else {\n            const itemIndicesRegex = new RegExp(matchedItem, 'g')\n            index = itemIndicesRegex.exec(targetString).index\n            indicesReg.push({\n              str: String(matchedItem),\n              regex: itemIndicesRegex\n            })\n          }\n          result.push({\n            0: String(matchedItem),\n            index: index\n          })\n        })\n      }\n      return result\n    },\n\n    addFallbackValues () {\n      const timeValue = {}\n      this.inUse.types.forEach(type => {\n        timeValue[this.getTokenByType(type)] = ''\n      })\n      this.timeValue = timeValue\n    },\n\n    setValueFromString (parsedValue, token) {\n      if (!token || !parsedValue) { return '' }\n      const tokenType = this.getTokenType(token)\n      if (!tokenType || !tokenType.length) { return '' }\n      const stdValue = (parsedValue !== this.getTokenByType(tokenType)) ? parsedValue : ''\n      this[tokenType] = stdValue\n      return stdValue\n    },\n\n    fillValues (forceEmit) {\n      const fullValues = {}\n\n      const baseHour = this.hour\n      const baseHourType = this.hourType\n\n      let apmValue\n\n      // Hour type or hour value is NOT set in the \"format\" string\n      if (!baseHourType || !this.isNumber(baseHour)) {\n        CONFIG.HOUR_TOKENS.forEach(token => fullValues[token] = '')\n        apmValue = this.lowerCasedApm(this.apm || '')\n        fullValues.a = apmValue\n        fullValues.A = apmValue.toUpperCase()\n\n      // Both Hour type and value are set\n      } else {\n        const hourValue = +baseHour\n        const apmValue = (this.baseOn12Hours && this.apm) ? this.lowerCasedApm(this.apm) : false\n\n        CONFIG.HOUR_TOKENS.forEach((token) => {\n          if (token === baseHourType) {\n            fullValues[token] = baseHour\n            return\n          }\n\n          let value\n          let apm\n          switch (token) {\n            case 'H':\n            case 'HH':\n            case 'k':\n            case 'kk':\n              if (this.baseOn12Hours) {\n                if (apmValue === 'pm') {\n                  value = hourValue < 12 ? hourValue + 12 : hourValue\n                } else if (['k', 'kk'].includes(token)) {\n                  value = hourValue === 12 ? 24 : hourValue\n                } else {\n                  value = hourValue % 12\n                }\n              } else {\n                if (['k', 'kk'].includes(token)) {\n                  value = hourValue === 0 ? 24 : hourValue\n                } else {\n                  value = hourValue % 24\n                }\n              }\n              fullValues[token] = this.formatValue(token, value)\n              break\n            case 'h':\n            case 'hh':\n              // h <-> hh\n              if (this.baseOn12Hours) {\n                value = hourValue\n                apm = apmValue || ''\n              // Read from other hour formats\n              } else {\n                if (hourValue > 11 && hourValue < 24) {\n                  apm = 'pm'\n                  value = hourValue === 12 ? 12 : hourValue % 12\n                } else {\n                  apm = 'am'\n                  value = hourValue % 12 === 0 ? 12 : hourValue\n                }\n              }\n              fullValues[token] = this.formatValue(token, value)\n              fullValues.a = apm\n              fullValues.A = apm.toUpperCase()\n              break\n          }\n        })\n      }\n\n      fullValues.m = this.formatValue('m', this.minute)\n      fullValues.mm = this.formatValue('mm', this.minute)\n      fullValues.s = this.formatValue('s', this.second)\n      fullValues.ss = this.formatValue('ss', this.second)\n\n      this.fullValues = fullValues\n\n      // On lazy mode, emit `input` and `change` events only when:\n      // - The user pick a new value and then close the dropdown\n      // - The user click the (\"x\") clear button\n      if (!this.lazy || forceEmit) {\n        this.emitTimeValue()\n      }\n\n      if (this.closeOnComplete && this.allValueSelected && this.showDropdown) {\n        this.toggleActive()\n      }\n    },\n\n    getFullData () {\n      if (!this.fullValues) {\n        this.fillValues()\n      }\n      return {\n        data: JSON.parse(JSON.stringify(this.fullValues)),\n        displayTime: this.inputIsEmpty ? '' : String(this.displayTime)\n      }\n    },\n\n    emitTimeValue () {\n      if (this.lazy && this.bakDisplayTime === this.displayTime) {\n        if (this.debugMode) {\n          this.debugLog('The value does not change on `lazy` mode. Skip the emitting `input` and `change` event.')\n        }\n        return\n      }\n\n      const fullData = this.getFullData()\n\n      if (this.useStringValue) {\n        this.$emit('input', fullData.displayTime)\n      } else {\n        const fullValues = fullData.data\n        const tokensInUse = this.inUse.tokens || []\n        const timeValue = {}\n        tokensInUse.forEach((token) => {\n          timeValue[token] = fullValues[token] || ''\n        })\n        this.$emit('input', JSON.parse(JSON.stringify(timeValue)))\n      }\n\n      this.$emit('change', fullData)\n    },\n\n    translate12hRange (value) {\n      const valueT = this.match12hRange(value)\n      if (+valueT[1] === 12) {\n        return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 0 : 12)\n      }\n      return +valueT[1] + (valueT[2].toLowerCase() === 'p' ? 12 : 0)\n    },\n\n    isDisabled (type, value) {\n      if (!this.isBasicType(type) || !this.inUse[type]) { return true }\n      switch (type) {\n        case 'hour':\n          return this.isDisabledHour(value)\n        case 'minute':\n        case 'second':\n          if (!this[`${type}RangeList`]) {\n            return false\n          }\n          return !this[`${type}RangeList`].includes(value)\n        case 'apm':\n          if (!this.restrictedHourRange) {\n            return false\n          }\n          return !this.has[this.lowerCasedApm(value)]\n        default:\n          return true\n      }\n    },\n\n    isDisabledHour (value) {\n      if (!this.restrictedHourRange) { return false }\n      if (this.baseOn12Hours) {\n        if (!this.apm || !this.apm.length) {\n          return false\n        } else {\n          const token = this.apm.toLowerCase() === 'am' ? 'a' : 'p'\n          return !this.restrictedHourRange.includes(`${+value}${token}`)\n        }\n      }\n      // Fallback for 'HH' and 'H hour format with a `hour-range` in a 12-hour form\n      if (\n        (this.hourType === 'HH' || this.hourType === 'H') &&\n        +value === 0 && this.restrictedHourRange.includes(24)\n      ) {\n        return false\n      }\n      return !this.restrictedHourRange.includes(+value)\n    },\n\n    notInInterval (section, value) {\n      if (!section || !this.isMinuteOrSecond(section)) { return }\n      if (this.opts[`${section}Interval`] === 1) { return false }\n      return +value % this.opts[`${section}Interval`] !== 0\n    },\n\n    renderRangeList (rawRange, section) {\n      if (!rawRange || !section || !this.isMinuteOrSecond(section)) { return [] }\n      const range = []\n      let formatedValue\n      rawRange.forEach(value => {\n        if (value instanceof Array) {\n          if (value.length > 2 && this.debugMode) {\n            this.debugLog(`Nested array within \"${section}-range\" must contain no more than two items. Only the first two items of ${JSON.stringify(value)} will be taken into account.`)\n          }\n          const start = value[0]\n          const end = value[1] || value[0]\n          for (let i = +start; i <= +end; i++) {\n            if (i < 0 || i > 59) { continue }\n            formatedValue = this.formatValue(this.getTokenByType(section), i)\n            if (!range.includes(formatedValue)) {\n              range.push(formatedValue)\n            }\n          }\n        } else {\n          if (+value < 0 || +value > 59) { return }\n          formatedValue = this.formatValue(this.getTokenByType(section), value)\n          if (!range.includes(formatedValue)) {\n            range.push(formatedValue)\n          }\n        }\n      })\n      range.sort((l, r) => { return l - r })\n      // Debug Mode\n      if (this.debugMode) {\n        const fullList = (section === 'minute' ? this.minutes : this.seconds) || []\n        const validItems = fullList.filter(item => range.includes(item))\n        if (!validItems || !validItems.length) {\n          if (section === 'minute') {\n            this.debugLog(`The minute list is empty due to the \"minute-range\" config\\nminute-range: ${JSON.stringify(this.minuteRange)}\\nminute-interval: ${this.opts.minuteInterval}`)\n          } else {\n            this.debugLog(`The second list is empty due to the \"second-range\" config\\nsecond-range: ${JSON.stringify(this.secondRange)}\\nsecond-interval: ${this.opts.secondInterval}`)\n          }\n        }\n      }\n      return range\n    },\n\n    forceApmSelection () {\n      if (this.manualInput) {\n        // Skip this to allow users to paste a string value from the clipboard in Manual Input mode\n        return\n      }\n      if (this.apmType && !this.apm) {\n        if (this.has.am || this.has.pm) {\n          this.doClearApmChecking = true\n          const apmValue = this.has.am ? 'am' : 'pm'\n          this.apm = this.apmType === 'A' ? apmValue.toUpperCase() : apmValue\n        }\n      }\n    },\n\n    emptyApmSelection () {\n      if (this.doClearApmChecking && this.hour === '' && this.minute === '' && this.second === '') {\n        this.apm = ''\n      }\n      this.doClearApmChecking = false\n    },\n\n    apmDisplayText (apmValue) {\n      if (this.amText && this.lowerCasedApm(apmValue) === 'am') {\n        return this.amText\n      }\n      if (this.pmText && this.lowerCasedApm(apmValue) === 'pm') {\n        return this.pmText\n      }\n      return apmValue\n    },\n\n    toggleActive () {\n      if (this.disabled) { return }\n      this.isActive = !this.isActive\n\n      if (this.isActive) {\n        this.isFocusing = true\n        if (this.manualInput) {\n          this.$emit('focus')\n        }\n        if (!this.opts.hideDropdown) {\n          this.setDropdownState(true)\n        }\n        // Record to check if value did change in the later phase\n        if (this.lazy) {\n          this.bakDisplayTime = String(this.displayTime || '')\n        }\n        if (this.manualInput && !this.inputIsEmpty) {\n          this.$nextTick(() => {\n            if (this.$refs.input && this.$refs.input.selectionStart === 0 && this.$refs.input.selectionEnd === this.displayTime.length) {\n              // Select the first slot instead of the whole value string when tabbed in\n              this.selectFirstSlot()\n            }\n          })\n        }\n      } else {\n        if (this.showDropdown) {\n          this.setDropdownState(false)\n        } else if (this.manualInput) {\n          this.$emit('blur', this.getFullData())\n        }\n        this.isFocusing = false\n        if (this.lazy) {\n          this.fillValues(true)\n          this.bakDisplayTime = undefined\n        }\n      }\n\n      if (this.restrictedHourRange && this.baseOn12Hours) {\n        this.showDropdown ? this.forceApmSelection() : this.emptyApmSelection()\n      }\n      if (this.showDropdown) {\n        this.checkForAutoScroll()\n      }\n    },\n\n    setDropdownState (toShow, fromUserClick = false) {\n      if (toShow) {\n        if (this.appendToBody) {\n          this.appendDropdownToBody()\n        }\n        this.keepFocusing()\n        if (this.autoDirectionEnabled) {\n          this.checkDropDirection()\n        }\n        this.showDropdown = true\n        this.$emit('open') \n        if (fromUserClick) {\n          if (this.fixedDropdownButton) {\n            this.isActive = true\n          }\n          this.$emit('blur', this.getFullData())\n          this.checkForAutoScroll()\n        }\n      } else {\n        this.showDropdown = false\n        this.$emit('close', this.getFullData())\n        if (this.appendToBody) {\n          this.removeDropdownFromBody()\n        }\n      }\n    },\n\n    appendDropdownToBody () {\n      const dropdown = this.$refs && this.$refs.dropdown\n      const body = document.getElementsByTagName('body')[0]\n      if (body && dropdown) {\n        window.addEventListener('scroll', this.updateDropdownPos)\n        dropdown.classList.add('vue__time-picker-dropdown')\n        this.updateDropdownPos()\n        body.appendChild(dropdown)\n      }\n    },\n\n    updateDropdownPos () {\n      if (!this.appendToBody) { return }\n      const dropdown = this.$refs && this.$refs.dropdown\n      const body = document.getElementsByTagName('body')[0]\n      if (body && dropdown) {\n        const box = this.$el.getBoundingClientRect()\n        if (this.dropdownDirClass === 'drop-up') {\n          dropdown.style.bottom = `${window.innerHeight - box.y}px`\n          dropdown.style.top = 'auto'\n        } else {\n          dropdown.style.top = `${box.y + box.height}px`\n          dropdown.style.bottom = 'auto'\n        }\n        dropdown.style.left = `${box.x}px`\n      }\n    },\n\n    removeDropdownFromBody () {\n      const dropdown = this.$refs && this.$refs.dropdown\n      const body = document.getElementsByTagName('body')[0]\n      if (body && dropdown && body.contains(dropdown)) {\n        body.removeChild(dropdown)\n      }\n      if (dropdown) {\n        dropdown.classList.remove('vue__time-picker-dropdown')\n        dropdown.style.top = ''\n        dropdown.style.bottom = ''\n        dropdown.style.left = ''\n        this.$el.appendChild(dropdown)\n      }\n      window.removeEventListener('scroll', this.updateDropdownPos)\n    },\n\n    blurEvent () {\n      if (this.manualInput && !this.opts.hideDropdown) {\n        // hideDropdown's `blur` event is handled somewhere else\n        this.$emit('blur', this.getFullData())\n      }\n    },\n\n    select (type, value) {\n      if (this.isBasicType(type) && !this.isDisabled(type, value)) {\n        this[type] = value\n        if (this.doClearApmChecking) {\n          this.doClearApmChecking = false\n        }\n      }\n    },\n\n    clearTime () {\n      if (this.disabled) { return }\n      this.hour = ''\n      this.minute = ''\n      this.second = ''\n      this.apm = ''\n\n      if (this.manualInput && this.$refs && this.$refs.input && this.$refs.input.value.length) {\n        this.$refs.input.value = ''\n      }\n\n      if (this.lazy) {\n        this.fillValues(true)\n      }\n    },\n\n    //\n    // Auto-Scroll\n    //\n\n    checkForAutoScroll () {\n      if (this.inputIsEmpty) { return }\n      if (this.autoScroll) {\n        this.$nextTick(() => {\n          this.scrollToSelectedValues()\n        })\n      } else if (this.advancedKeyboard) {\n        // Auto-focus on selected value in the first column for advanced-keyboard\n        this.$nextTick(() => {\n          const firstColumn = this.inUse.types[0]\n          this.scrollToSelected(firstColumn, true)\n        })\n      }\n    },\n\n    scrollToSelected (column, allowFallback = false) {\n      if (!this.timeValue || this.inputIsEmpty) { return }\n      let targetList\n      if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n        targetList = this.$refs.dropdown.querySelectorAll(`ul.${column}s`)[0]\n      } else {\n        targetList = this.$el.querySelectorAll(`ul.${column}s`)[0]\n      }\n      let targetValue = this.activeItemInCol(column)[0]\n      if (!targetValue && allowFallback) {\n        // No value selected in the target column, fallback to the first found valid item\n        targetValue = this.validItemsInCol(column)[0]\n      }\n      if (targetList && targetValue) {\n        targetList.scrollTop = targetValue.offsetTop || 0\n        if (this.advancedKeyboard) {\n          targetValue.focus()\n        }\n      }\n    },\n\n    scrollToSelectedValues () {\n      if (!this.timeValue || this.inputIsEmpty) { return }\n      this.inUse.types.forEach(section => {\n        this.scrollToSelected(section)\n      })\n    },\n\n    //\n    // Additional Keyboard Navigation\n    //\n\n    onFocus () {\n      if (this.disabled) { return }\n      if (!this.isFocusing) {\n        this.isFocusing = true\n      }\n      if (!this.isActive) {\n        this.toggleActive()\n      }\n    },\n\n    escBlur () {\n      if (this.disabled) { return }\n      window.clearTimeout(this.debounceTimer)\n      this.isFocusing = false\n      const inputBox = this.$el.querySelectorAll('input.display-time')[0]\n      if (inputBox) {\n        inputBox.blur()\n      }\n    },\n\n    debounceBlur () {\n      if (this.disabled) { return }\n      this.isFocusing = false\n      window.clearTimeout(this.debounceTimer)\n      this.debounceTimer = window.setTimeout(() => {\n        window.clearTimeout(this.debounceTimer)\n        this.onBlur()\n      }, this.opts.blurDelay)\n    },\n\n    onBlur () {\n      if (!this.disabled && !this.isFocusing && this.isActive) {\n        this.toggleActive()\n      }\n    },\n\n    keepFocusing () {\n      if (this.disabled) { return }\n      window.clearTimeout(this.debounceTimer)\n      if (!this.isFocusing) {\n        this.isFocusing = true\n      }\n    },\n\n    onTab (column, value, evt) {\n      if (this.appendToBody && evt.shiftKey) {\n        const firstColumn = this.inUse.types[0]\n        if (column !== firstColumn) { return }\n        const firstValidValue = this.validItemsInCol(firstColumn)[0]\n        // Is the first valid item in the first column\n        if (firstValidValue && firstValidValue.getAttribute('data-key') === String(value)) {\n          evt.preventDefault()\n          // Focus back on <input>\n          if (this.$refs && this.$refs.input) {\n            this.$refs.input.focus()\n          }\n        }\n      }\n    },\n\n    validItemsInCol (column) {\n      const columnClass = `${column}s`\n      if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n        return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n      }\n      return this.$el.querySelectorAll(`ul.${columnClass} > li:not(.hint):not([disabled])`)\n    },\n\n    activeItemInCol (column) {\n      const columnClass = `${column}s`\n      if (this.appendToBody && this.$refs && this.$refs.dropdown) {\n        return this.$refs.dropdown.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n      }\n      return this.$el.querySelectorAll(`ul.${columnClass} > li.active:not(.hint)`)\n    },\n\n    getClosestSibling (column, dataKey, getPrevious = false) {\n      const siblingsInCol = this.validItemsInCol(column)\n      const selfIndex = Array.prototype.findIndex.call(siblingsInCol, (sbl) => {\n        return sbl.getAttribute('data-key') === dataKey\n      })\n\n      // Already the first item\n      if (getPrevious && selfIndex === 0) {\n        return siblingsInCol[siblingsInCol.length - 1]\n      }\n      // Already the last item\n      if (!getPrevious && selfIndex === siblingsInCol.length - 1) {\n        return siblingsInCol[0]\n      }\n      // Selected value not in the valid values list\n      if (selfIndex < 0) {\n        return siblingsInCol[0]\n      }\n\n      if (getPrevious) {\n        return siblingsInCol[selfIndex - 1]\n      }\n      return siblingsInCol[selfIndex + 1]\n    },\n\n    prevItem (column, dataKey, isManualInput = false) {\n      const targetItem = this.getClosestSibling(column, dataKey, true)\n      if (targetItem) {\n        return isManualInput ? targetItem : targetItem.focus()\n      }\n    },\n\n    nextItem (column, dataKey, isManualInput = false) {\n      const targetItem = this.getClosestSibling(column, dataKey, false)\n      if (targetItem) {\n        return isManualInput ? targetItem : targetItem.focus()\n      }\n    },\n\n    getSideColumnName (currentColumn, toLeft = false) {\n      const currentColumnIndex = this.inUse.types.indexOf(currentColumn)\n      if (toLeft && currentColumnIndex <= 0) {\n        if (this.debugMode) {\n          this.debugLog('You\\'re in the leftmost list already')\n        }\n        return\n      } else if (!toLeft && currentColumnIndex === (this.inUse.types.length - 1)) {\n        if (this.debugMode) {\n          this.debugLog('You\\'re in the rightmost list already')\n        }\n        return\n      }\n      return this.inUse.types[toLeft ? currentColumnIndex - 1 : currentColumnIndex + 1]\n    },\n\n    getFirstItemInSideColumn (currentColumn, toLeft = false) {\n      const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n      if (!targetColumn) { return }\n      const listItems = this.validItemsInCol(targetColumn)\n      if (listItems && listItems[0]) {\n        return listItems[0]\n      }\n    },\n\n    getActiveItemInSideColumn (currentColumn, toLeft = false) {\n      const targetColumn = this.getSideColumnName(currentColumn, toLeft)\n      if (!targetColumn) { return }\n      const activeItems = this.activeItemInCol(targetColumn)\n      if (activeItems && activeItems[0]) {\n        return activeItems[0]\n      }\n    },\n\n    toLeftColumn (currentColumn) {\n      const targetItem = this.getActiveItemInSideColumn(currentColumn, true) || this.getFirstItemInSideColumn(currentColumn, true)\n      if (targetItem) {\n        targetItem.focus()\n      }\n    },\n\n    toRightColumn (currentColumn) {\n      const targetItem = this.getActiveItemInSideColumn(currentColumn, false) || this.getFirstItemInSideColumn(currentColumn, false)\n      if (targetItem) {\n        targetItem.focus()\n      }\n    },\n\n    //\n    // Manual Input\n    //\n\n    onMouseDown () {\n      if (!this.manualInput) { return }\n      window.clearTimeout(this.selectionTimer)\n      this.selectionTimer = window.setTimeout(() => {\n        window.clearTimeout(this.selectionTimer)\n        if (this.$refs && this.$refs.input) {\n          const nearestSlot = this.getNearestChunkByPos(this.$refs.input.selectionStart || 0)\n          this.debounceSetInputSelection(nearestSlot)\n        }\n      }, 50)\n    },\n\n    keyDownHandler (evt) {\n      if (evt.isComposing || evt.keyCode === 229) {\n        // Skip IME inputs\n        evt.preventDefault()\n        evt.stopPropagation()\n        return false\n      }\n      // Numbers\n      if ((evt.keyCode >= 48 && evt.keyCode <= 57) || (evt.keyCode >= 96 && evt.keyCode <= 105)) {\n        evt.preventDefault()\n        this.keyboardInput(evt.key)\n      // A|P|M\n      } else if ([65, 80, 77].includes(evt.keyCode)) {\n        evt.preventDefault()\n        this.keyboardInput(evt.key, true)\n      // Arrow keys\n      } else if (evt.keyCode >= 37 && evt.keyCode <= 40) {\n        evt.preventDefault()\n        this.clearKbInputLog()\n        this.arrowHandler(evt)\n      // Delete|Backspace\n      } else if (evt.keyCode === 8 || evt.keyCode === 46) {\n        evt.preventDefault()\n        this.clearKbInputLog()\n        this.clearTime()\n      // Tab\n      } else if (evt.keyCode === 9) {\n        this.clearKbInputLog()\n        this.tabHandler(evt)\n      // Colon|Space\n      } else if (evt.keyCode === 186 || evt.keyCode === 32) {\n        evt.preventDefault()\n        this.clearKbInputLog()\n        this.toNextSlot()\n      // Prevent any Non-ESC and non-pasting inputs\n      } else if (evt.keyCode !== 27 && !(evt.metaKey || evt.ctrlKey)) {\n        evt.preventDefault()\n      }\n    },\n\n    onCompostionStart (evt) {\n      evt.preventDefault()\n      evt.stopPropagation()\n      this.bakCurrentPos = this.getCurrentTokenChunk()\n      return false\n    },\n\n    onCompostionEnd (evt) {\n      evt.preventDefault()\n      evt.stopPropagation()\n\n      const cpsData = evt.data\n      let inputIsCustomApmText = false\n      if (this.has.customApmText) {\n        inputIsCustomApmText = this.isCustomApmText(cpsData)\n      }\n      if (inputIsCustomApmText) {\n        this.setSanitizedValueToSection('apm', inputIsCustomApmText)\n      }\n\n      this.$refs.input.value = this.has.customApmText ? this.customDisplayTime : this.displayTime\n\n      this.$nextTick(() => {\n        if (this.bakCurrentPos) {\n          const bakPos = JSON.parse(JSON.stringify(this.bakCurrentPos))\n          if (inputIsCustomApmText) {\n            bakPos.end = (bakPos.start + cpsData.length)\n          }\n          this.debounceSetInputSelection(bakPos)\n          this.bakCurrentPos = null\n        }\n      })\n      return false\n    },\n\n    pasteHandler (evt) {\n      evt.preventDefault()\n      let pastingText = (evt.clipboardData || window.clipboardData).getData('text')\n      if (this.debugMode) {\n        this.debugLog(`Pasting value \"${pastingText}\" from clipboard`)\n      }\n      if (!pastingText || !pastingText.length) { return }\n\n      // Replace custom AM/PM text (if any)\n      if (this.has.customApmText) {\n        pastingText = this.replaceCustomApmText(pastingText)\n      }\n\n      if (this.inputIsEmpty) {\n        this.readStringValues(pastingText)\n      } else {\n        this.kbInputLog = pastingText.substr(-2, 2)\n        this.setKbInput()\n        this.debounceClearKbLog()\n      }\n    },\n\n    arrowHandler (evt) {\n      const direction = { 37: 'L', 38: 'U', 39: 'R', 40: 'D' }[evt.keyCode]\n      if (direction === 'U' || direction === 'D') {\n        if (this.inputIsEmpty) {\n          this.selectFirstValidValue()\n        } else {\n          const currentChunk = this.getCurrentTokenChunk()\n          if (!currentChunk) {\n            this.selectFirstValidValue()\n            return\n          }\n          const tokenType = currentChunk.type\n          this.getClosestValidItemInCol(tokenType, this[tokenType], direction)\n          const newChunkPos = this.getCurrentTokenChunk()\n          this.debounceSetInputSelection(newChunkPos)\n        }\n      } else if (direction === 'R') {\n        this.toLateralToken(false)\n      } else if (direction === 'L') {\n        this.toLateralToken(true)\n      }\n    },\n\n    tabHandler (evt) {\n      if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n        const currentChunk = this.getCurrentTokenChunk()\n        if (!currentChunk) { return }\n        const firstChunk = this.tokenChunksPos[0]\n        const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n        if ((evt.shiftKey && currentChunk.token !== firstChunk.token) || (!evt.shiftKey && currentChunk.token !== lastChunk.token)) {\n          evt.preventDefault()\n          this.toLateralToken(evt.shiftKey)\n        }\n      } else if (this.appendToBody && this.advancedKeyboard) {\n        if (evt.shiftKey) { return }\n        evt.preventDefault()\n        if (this.inputIsEmpty) {\n          const firstColumn = this.inUse.types[0]\n          const targetValue = this.validItemsInCol(firstColumn)[0]\n          if (targetValue) {\n            targetValue.focus()\n          }\n        }\n      }\n    },\n\n    keyboardInput (newChar, isApm = false) {\n      const currentChunk = this.getCurrentTokenChunk()\n      if (!currentChunk || (currentChunk.type !== 'apm' && isApm) || (currentChunk.type === 'apm' && !isApm)) { return }\n      this.kbInputLog = `${this.kbInputLog.substr(-1)}${newChar}`\n      this.setKbInput()\n      this.debounceClearKbLog()\n    },\n\n    clearKbInputLog () {\n      window.clearTimeout(this.kbInputTimer)\n      this.kbInputLog = ''\n    },\n\n    debounceClearKbLog () {\n      window.clearTimeout(this.kbInputTimer)\n      this.kbInputTimer = window.setTimeout(() => {\n        this.clearKbInputLog()\n      }, this.opts.manualInputTimeout)\n    },\n\n    setKbInput (value) {\n      value = value || this.kbInputLog\n      const currentChunk = this.getCurrentTokenChunk()\n      if (!currentChunk || !value || !value.length) { return }\n      const chunkType = currentChunk.type\n      const chunkToken = currentChunk.token\n\n      let validValue\n      if (chunkType === 'apm') {\n        if (this.lowerCasedApm(value).includes('a')) {\n          validValue = 'am'\n        } else if (this.lowerCasedApm(value).includes('p')) {\n          validValue = 'pm'\n        }\n        if (validValue) {\n          validValue = chunkToken === 'A' ? validValue.toUpperCase() : validValue\n        }\n      } else {\n        if (this.isValidValue(chunkToken, value)) {\n          validValue = value\n        } else {\n          const lastInputValue = this.formatValue(chunkToken, value.substr(-1))\n          if (this.isValidValue(chunkToken, lastInputValue)) {\n            validValue = lastInputValue\n          }\n        }\n      }\n\n      if (validValue) {\n        this.setSanitizedValueToSection(chunkType, validValue)\n        const newChunkPos = this.getCurrentTokenChunk()\n        this.debounceSetInputSelection(newChunkPos)      \n      }\n      if (this.debugMode) {\n        if (validValue) {\n          this.debugLog(`Successfully set value \"${validValue}\" from latest input \"${value}\" for the \"${chunkType}\" slot`)\n        } else {\n          this.debugLog(`Value \"${value}\" is invalid in the \"${chunkType}\" slot`)\n        }\n      }\n    },\n\n    // Form Autofill\n    onChange () {\n      if (!this.manualInput || !this.$refs || !this.$refs.input) { return }\n      const autoFillValue = this.$refs.input.value || ''\n      if (autoFillValue && autoFillValue.length) {\n        this.readStringValues(autoFillValue)\n      }\n    },\n\n    getNearestChunkByPos (startPos) {\n      if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n      let nearest\n      let nearestDelta = -1\n      for (let i = 0; i < this.tokenChunksPos.length; i++) {\n        const chunk = JSON.parse(JSON.stringify(this.tokenChunksPos[i]))\n        if (chunk.start === startPos) {\n          return chunk\n        }\n        const delta = Math.abs(chunk.start - startPos)\n        if (nearestDelta < 0) {\n          nearest = chunk\n          nearestDelta = delta\n        } else {\n          if (nearestDelta <= delta) {\n            return nearest\n          }\n          nearestDelta = delta\n          nearest = chunk\n        }\n      }\n      return nearest\n    },\n\n    selectFirstValidValue () {\n      if (!this.tokenChunksPos || !this.tokenChunksPos.length) { return }\n      const firstSlotType = this.tokenChunksPos[0].type\n      if (firstSlotType === 'hour') {\n        this.getClosestHourItem()\n      } else {\n        this.getClosestValidItemInCol(firstSlotType, this[firstSlotType])\n      }\n      this.selectFirstSlot()\n    },\n\n    getClosestHourItem (currentValue, direction = 'U') {\n      if (!this.validHoursList || !this.validHoursList.length) {\n        if (this.debugMode) {\n          this.debugLog(`No valid hour values found, please check your \"hour-range\" config\\nhour-range: ${JSON.stringify(this.hourRange)}`)\n        }\n        return\n      }\n      if (!currentValue) {\n        this.setManualHour(this.validHoursList[0])\n        return\n      }\n      const currentIndex = this.validHoursList.findIndex(item => {\n        if (!this.baseOn12Hours) {\n          return item === currentValue\n        } else {\n          const valueKey = `${currentValue}${this.lowerCasedApm(this.apm) === 'pm' ? 'p' : 'a'}` \n          return item === valueKey\n        }\n      })\n      let nextIndex\n      if (currentIndex === -1) {\n        nextIndex = 0\n      } else if (direction === 'D') {\n        nextIndex = currentIndex === 0 ? this.validHoursList.length - 1 : currentIndex - 1\n      } else {\n        nextIndex = (currentIndex + 1) % this.validHoursList.length\n      }\n      const nextItem = this.validHoursList[nextIndex]\n      this.setManualHour(nextItem)\n    },\n\n    getClosestValidItemInCol (column, currentValue, direction = 'U') {\n      if (column === 'hour') {\n        this.getClosestHourItem(currentValue, direction)\n      } else {\n        const nextItem = direction === 'D' ? this.prevItem(column, this[column], true) : this.nextItem(column, this[column], true)\n        if (nextItem) {\n          this.select(column, nextItem.getAttribute('data-key'))\n        }\n      }\n    },\n\n    setSanitizedValueToSection (section, inputValue) {\n      if (!section || !this.getTokenByType(section)) { return }\n      // NOTE: Disabled values are allowed here, followed by an 'error' event, though\n      const sanitizedValue = this.sanitizedValue(this.getTokenByType(section), inputValue)\n      this[section] = sanitizedValue\n    },\n\n    setManualHour (nextItem) {\n      if (this.is12hRange(nextItem)) {\n        const hourT = this.match12hRange(nextItem)\n        const apmValue = hourT[2] === 'a' ? 'AM' : 'PM'\n        this.setSanitizedValueToSection('apm', this.apmType === 'a' ? apmValue.toLowerCase() : apmValue)\n        this.setSanitizedValueToSection('hour', hourT[1])\n      } else {\n        this.setSanitizedValueToSection('hour', nextItem)\n      }\n    },\n\n    debounceSetInputSelection ({start = 0, end = 0 }) {\n      this.$nextTick(() => {\n        this.setInputSelectionRange(start, end)\n      })\n      window.clearTimeout(this.selectionTimer)\n      this.selectionTimer = window.setTimeout(() => {\n        window.clearTimeout(this.selectionTimer)\n        // Double-check selection for 12hr format\n        if (this.$refs.input && (this.$refs.input.selectionStart !== start || this.$refs.input.selectionEnd !== end)) {\n          this.setInputSelectionRange(start, end)\n        }\n      }, 30)\n    },\n\n    setInputSelectionRange (start, end) {\n      if (this.$refs && this.$refs.input) {\n        this.$refs.input.setSelectionRange(start, end)\n      }\n    },\n\n    getCurrentTokenChunk () {\n      return this.getNearestChunkByPos((this.$refs.input && this.$refs.input.selectionStart) || 0)\n    },\n\n    selectFirstSlot () {\n      const firstChunkPos = this.getNearestChunkByPos(0)\n      this.debounceSetInputSelection(firstChunkPos)\n    },\n\n    toNextSlot () {\n      if (!this.inputIsEmpty && this.tokenChunksPos && this.tokenChunksPos.length) {\n        const currentChunk = this.getCurrentTokenChunk()\n        if (!currentChunk) { return }\n        const lastChunk = this.tokenChunksPos[this.tokenChunksPos.length - 1]\n        if (currentChunk.token !== lastChunk.token) {\n          this.toLateralToken(false)\n        }\n      }\n    },\n\n    toLateralToken (toLeft) {\n      const currentChunk = this.getCurrentTokenChunk()\n      if (!currentChunk) {\n        this.selectFirstValidValue()\n        return\n      }\n      const currentChunkIndex = this.tokenChunksPos.findIndex(chk => chk.token === currentChunk.token)\n      if ((!toLeft && currentChunkIndex >= this.tokenChunksPos.length - 1) || (toLeft && currentChunkIndex === 0)) {\n        if (this.debugMode) {\n          if (toLeft) {\n            this.debugLog('You\\'re in the leftmost slot already')\n          } else {\n            this.debugLog('You\\'re in the rightmost slot already')\n          }\n        }\n        return\n      }\n      const targetSlotPos = toLeft ? this.tokenChunksPos[currentChunkIndex - 1] : this.tokenChunksPos[currentChunkIndex + 1]\n      this.debounceSetInputSelection(targetSlotPos)\n    },\n\n    isCustomApmText (inputData) {\n      if (!inputData || !inputData.length) { return false }\n      if (this.amText && this.amText === inputData) {\n        return this.apmType === 'A' ? 'AM' : 'am'\n      }\n      if (this.pmText && this.pmText === inputData) {\n        return this.apmType === 'A' ? 'PM' : 'pm'\n      }\n      return false\n    },\n\n    replaceCustomApmText (inputString) {\n      if (this.amText && this.amText.length && inputString.includes(this.amText)) {\n        return inputString.replace(new RegExp(this.amText, 'g'), this.apmType === 'A' ? 'AM' : 'am')\n      } else if (this.pmText && this.pmText.length && inputString.includes(this.pmText)) {\n        return inputString.replace(new RegExp(this.pmText, 'g'), this.apmType === 'A' ? 'PM' : 'pm')\n      }\n      return inputString\n    },\n\n    checkDropDirection () {\n      if (!this.$el) { return }\n      let container\n      if (this.containerId && this.containerId.length) {\n        container = document.getElementById(this.containerId)\n        if (!container && this.debugMode) {\n          this.debugLog(`Container with id \"${this.containerId}\" not found. Fallback to document body.`)\n        }\n      }\n      const el = this.$el\n      let spaceDown\n      if (container && container.offsetHeight) {\n        // Valid container found\n        spaceDown = (container.offsetTop + container.offsetHeight) - (el.offsetTop + el.offsetHeight)\n      } else {\n        // Fallback to document body\n        const docHeight = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)\n        spaceDown = docHeight - (el.offsetTop + el.offsetHeight)\n      }\n      this.forceDropOnTop = this.opts.dropOffsetHeight > spaceDown\n    },\n\n    //\n    // Helpers\n    //\n\n    is12hRange (value) {\n      return /^\\d{1,2}(a|p|A|P)$/.test(value)\n    },\n\n    match12hRange (value) {\n      return value.match(/^(\\d{1,2})(a|p|A|P)$/)\n    },\n\n    isNumber (value) {\n      return !isNaN(parseFloat(value)) && isFinite(value)\n    },\n\n    isBasicType (type) {\n      return CONFIG.BASIC_TYPES.includes(type)\n    },\n\n    lowerCasedApm (apmValue) {\n      return (apmValue || '').toLowerCase()\n    },\n\n    getTokenRegex (token) {\n      switch (token) {\n        case 'HH':\n          return '([01][0-9]|2[0-3]|H{2})'\n        case 'H':\n          return '([0-9]{1}|1[0-9]|2[0-3]|H{1})'\n        case 'hh':\n          return '(0[1-9]|1[0-2]|h{2})'\n        case 'h':\n          return '([1-9]{1}|1[0-2]|h{1})'\n        case 'kk':\n          return '(0[1-9]|1[0-9]|2[0-4]|k{2})'\n        case 'k':\n          return '([1-9]{1}|1[0-9]|2[0-4]|k{1})'\n        case 'mm':\n          return '([0-5][0-9]|m{2})'\n        case 'ss':\n          return '([0-5][0-9]|s{2})'\n        case 'm':\n          return '([0-9]{1}|[1-5][0-9]|m{1})'\n        case 's':\n          return '([0-9]{1}|[1-5][0-9]|s{1})'\n        case 'A':\n          return '(AM|PM|A{1})'\n        case 'a':\n          return '(am|pm|a{1})'\n        default:\n          return ''\n      }\n    },\n\n    isEmptyValue (targetToken, testValue) {\n      return (!testValue || !testValue.length) || (testValue && testValue === targetToken)\n    },\n\n    isValidValue (targetToken, testValue) {\n      if (!targetToken || this.isEmptyValue(targetToken, testValue)) { return false }\n      const tokenRegexStr = this.getTokenRegex(targetToken)\n      if (!tokenRegexStr || !tokenRegexStr.length) { return false }\n      return (new RegExp(`^${tokenRegexStr}$`)).test(testValue)\n    },\n\n    sanitizedValue (targetToken, inputValue) {\n      if (this.isValidValue(targetToken, inputValue)) {\n        return inputValue\n      }\n      return ''\n    },\n\n    getTokenType (token) {\n      return this.inUse.types[this.inUse.tokens.indexOf(token)] || ''\n    },\n\n    getTokenByType (type) {\n      return this[`${type}Type`] || ''\n    },\n\n    isMinuteOrSecond (type) {\n      return ['minute', 'second'].includes(type)\n    },\n\n    debugLog (logText) {\n      if (!logText || !logText.length) { return }\n      let identifier = ''\n      if (this.id) {\n        identifier += `#${this.id}`\n      }\n      if (this.name) {\n        identifier += `[name=${this.name}]`\n      }\n      if (this.inputClass) {\n        let inputClasses = []\n        if (typeof this.inputClass === 'string') {\n          inputClasses = this.inputClass.split(/\\s/g)\n        } else if (Array.isArray(this.inputClass)) {\n          inputClasses = [].concat([], this.inputClass)\n        } else if (typeof this.inputClass === 'object') {\n          Object.keys(this.inputClass).forEach(clsName => {\n            if (this.inputClass[clsName]) {\n              inputClasses.push(clsName)\n            }\n          })\n        }\n        for (let inputClass of inputClasses) {\n          if (inputClass && inputClass.trim().length) {\n            identifier += `.${inputClass.trim()}`\n          }\n        }\n      }\n      const finalLogText = `DEBUG: ${logText}${identifier ? `\\n\\t(${identifier})` : '' }`\n      if (window.console.debug && typeof window.console.debug === 'function') {\n        window.console.debug(finalLogText)\n      } else {\n        window.console.log(finalLogText)\n      }\n    }\n  },\n\n  mounted () {\n    window.clearTimeout(this.debounceTimer)\n    window.clearTimeout(this.selectionTimer)\n    window.clearTimeout(this.kbInputTimer)\n    this.renderFormat()\n  },\n\n  beforeDestroy () {\n    window.clearTimeout(this.debounceTimer)\n    window.clearTimeout(this.selectionTimer)\n    window.clearTimeout(this.kbInputTimer)\n  }\n}\n</script>\n\n<template>\n<span class=\"vue__time-picker time-picker\" :style=\"inputWidthStyle\">\n  <input type=\"text\" class=\"display-time\" ref=\"input\"\n         :class=\"[inputClass, {'is-empty': inputIsEmpty, 'invalid': hasInvalidInput, 'all-selected': allValueSelected, 'disabled': disabled, 'has-custom-icon': $slots && $slots.icon }]\"\n         :style=\"inputWidthStyle\"\n         :id=\"id\"\n         :name=\"name\"\n         :value=\"inputIsEmpty ? null : customDisplayTime\"\n         :placeholder=\"placeholder ? placeholder : formatString\"\n         :tabindex=\"disabled ? -1 : tabindex\"\n         :disabled=\"disabled\"\n         :readonly=\"!manualInput\"\n         :autocomplete=\"autocomplete\"\n         @focus=\"onFocus\"\n         @change=\"onChange\"\n         @blur=\"debounceBlur(); blurEvent()\"\n         @mousedown=\"onMouseDown\"\n         @keydown=\"keyDownHandler\"\n         @compositionstart=\"onCompostionStart\"\n         @compositionend=\"onCompostionEnd\"\n         @paste=\"pasteHandler\"\n         @keydown.esc.exact=\"escBlur\" />\n  <div class=\"controls\" v-if=\"showClearBtn || showDropdownBtn\" tabindex=\"-1\">\n    <span v-if=\"!isActive && showClearBtn\" class=\"clear-btn\" tabindex=\"-1\"\n          :class=\"{'has-custom-btn': $slots && $slots.clearButton }\"\n          @click=\"clearTime\">\n      <slot name=\"clearButton\"><span class=\"char\">&times;</span></slot>\n    </span>\n    <span v-if=\"showDropdownBtn\" class=\"dropdown-btn\" tabindex=\"-1\"\n          :class=\"{'has-custom-btn': $slots && $slots.dropdownButton }\"\n          @click=\"setDropdownState(fixedDropdownButton ? !showDropdown : true, true)\"\n          @mousedown=\"keepFocusing\">\n      <slot name=\"dropdownButton\"><span class=\"char\">&dtrif;</span></slot>\n    </span>\n  </div>\n  <div class=\"custom-icon\" v-if=\"$slots && $slots.icon\"><slot name=\"icon\"></slot></div>\n  <div class=\"time-picker-overlay\" v-if=\"showDropdown\" @click=\"toggleActive\" tabindex=\"-1\"></div>\n  <div class=\"dropdown\" ref=\"dropdown\" v-show=\"showDropdown\" tabindex=\"-1\"\n       :class=\"[dropdownDirClass]\" :style=\"inputWidthStyle\"\n       @mouseup=\"keepFocusing\" @click.stop=\"\">\n    <div class=\"select-list\" :style=\"inputWidthStyle\" tabindex=\"-1\">\n      <!-- Common Keyboard Support: less event listeners -->\n      <template v-if=\"!advancedKeyboard\">\n        <template v-for=\"column in columnsSequence\">\n          <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"hourLabelText\"></li>\n            <template v-for=\"(hr, hIndex) in hours\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                  :key=\"hIndex\"\n                  :class=\"{active: hour === hr}\"\n                  :disabled=\"isDisabled('hour', hr)\"\n                  :data-key=\"hr\"\n                  v-text=\"hr\"\n                  @click=\"select('hour', hr)\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"minuteLabelText\"></li>\n            <template v-for=\"(m, mIndex) in minutes\">\n              <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                  :key=\"mIndex\"\n                  :class=\"{active: minute === m}\"\n                  :disabled=\"isDisabled('minute', m)\"\n                  :data-key=\"m\"\n                  v-text=\"m\"\n                  @click=\"select('minute', m)\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"secondLabelText\"></li>\n            <template v-for=\"(s, sIndex) in seconds\">\n              <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                  :key=\"sIndex\"\n                  :class=\"{active: second === s}\"\n                  :disabled=\"isDisabled('second', s)\"\n                  :data-key=\"s\"\n                  v-text=\"s\"\n                  @click=\"select('second', s)\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"apmLabelText\"></li>\n            <template v-for=\"(a, aIndex) in apms\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                  :key=\"aIndex\"\n                  :class=\"{active: apm === a}\"\n                  :disabled=\"isDisabled('apm', a)\"\n                  :data-key=\"a\"\n                  v-text=\"apmDisplayText(a)\"\n                  @click=\"select('apm', a)\"></li>\n            </template>\n          </ul>\n        </template>\n      </template><!-- / Common Keyboard Support -->\n\n      <!--\n        Advanced Keyboard Support\n        Addeds hundreds of additional event lisenters\n      -->\n      <template v-if=\"advancedKeyboard\">\n        <template v-for=\"column in columnsSequence\">\n          <ul v-if=\"column === 'hour'\" :key=\"column\" class=\"hours\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"hourLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(hr, hIndex) in hours\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('hour', hr))\"\n                  :key=\"hIndex\"\n                  :class=\"{active: hour === hr}\"\n                  :tabindex=\"isDisabled('hour', hr) ? -1 : tabindex\"\n                  :data-key=\"hr\"\n                  :disabled=\"isDisabled('hour', hr)\"\n                  v-text=\"hr\"\n                  @click=\"select('hour', hr)\"\n                  @keydown.tab=\"onTab('hour', hr, $event)\"\n                  @keydown.space.prevent=\"select('hour', hr)\"\n                  @keydown.enter.prevent=\"select('hour', hr)\"\n                  @keydown.up.prevent=\"prevItem('hour', hr)\"\n                  @keydown.down.prevent=\"nextItem('hour', hr)\"\n                  @keydown.left.prevent=\"toLeftColumn('hour')\"\n                  @keydown.right.prevent=\"toRightColumn('hour')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'minute'\" :key=\"column\" class=\"minutes\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"minuteLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(m, mIndex) in minutes\">\n              <li v-if=\"!opts.hideDisabledMinutes || (opts.hideDisabledMinutes && !isDisabled('minute', m))\"\n                  :key=\"mIndex\"\n                  :class=\"{active: minute === m}\"\n                  :tabindex=\"isDisabled('minute', m) ? -1 : tabindex\"\n                  :data-key=\"m\"\n                  :disabled=\"isDisabled('minute', m)\"\n                  v-text=\"m\"\n                  @click=\"select('minute', m)\"\n                  @keydown.tab=\"onTab('minute', m, $event)\"\n                  @keydown.space.prevent=\"select('minute', m)\"\n                  @keydown.enter.prevent=\"select('minute', m)\"\n                  @keydown.up.prevent=\"prevItem('minute', m)\"\n                  @keydown.down.prevent=\"nextItem('minute', m)\"\n                  @keydown.left.prevent=\"toLeftColumn('minute')\"\n                  @keydown.right.prevent=\"toRightColumn('minute')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'second'\" :key=\"column\" class=\"seconds\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"secondLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(s, sIndex) in seconds\">\n              <li v-if=\"!opts.hideDisabledSeconds || (opts.hideDisabledSeconds && !isDisabled('second', s))\"\n                  :key=\"sIndex\"\n                  :class=\"{active: second === s}\"\n                  :tabindex=\"isDisabled('second', s) ? -1 : tabindex\"\n                  :data-key=\"s\"\n                  :disabled=\"isDisabled('second', s)\"\n                  v-text=\"s\"\n                  @click=\"select('second', s)\"\n                  @keydown.tab=\"onTab('second', s, $event)\"\n                  @keydown.space.prevent=\"select('second', s)\"\n                  @keydown.enter.prevent=\"select('second', s)\"\n                  @keydown.up.prevent=\"prevItem('second', s)\"\n                  @keydown.down.prevent=\"nextItem('second', s)\"\n                  @keydown.left.prevent=\"toLeftColumn('second')\"\n                  @keydown.right.prevent=\"toRightColumn('second')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n          <ul v-if=\"column === 'apm'\" :key=\"column\" class=\"apms\" tabindex=\"-1\" @scroll=\"keepFocusing\">\n            <li class=\"hint\" v-text=\"apmLabelText\" tabindex=\"-1\"></li>\n            <template v-for=\"(a, aIndex) in apms\">\n              <li v-if=\"!opts.hideDisabledHours || (opts.hideDisabledHours && !isDisabled('apm', a))\"\n                  :key=\"aIndex\"\n                  :class=\"{active: apm === a}\"\n                  :tabindex=\"isDisabled('apm', a) ? -1 : tabindex\"\n                  :data-key=\"a\"\n                  :disabled=\"isDisabled('apm', a)\"\n                  v-text=\"apmDisplayText(a)\"\n                  @click=\"select('apm', a)\"\n                  @keydown.tab=\"onTab('apm', a, $event)\"\n                  @keydown.space.prevent=\"select('apm', a)\"\n                  @keydown.enter.prevent=\"select('apm', a)\"\n                  @keydown.up.prevent=\"prevItem('apm', a)\"\n                  @keydown.down.prevent=\"nextItem('apm', a)\"\n                  @keydown.left.prevent=\"toLeftColumn('apm')\"\n                  @keydown.right.prevent=\"toRightColumn('apm')\"\n                  @keydown.esc.exact=\"debounceBlur\"\n                  @blur=\"debounceBlur\"\n                  @focus=\"keepFocusing\"></li>\n            </template>\n          </ul>\n        </template>\n      </template><!-- / Advanced Keyboard Support -->\n    </div>\n  </div>\n</span>\n</template>\n\n<style>\n.vue__time-picker {\n  display: inline-block;\n  position: relative;\n  font-size: 1em;\n  width: 10em;\n  font-family: sans-serif;\n  vertical-align: middle;\n}\n\n.vue__time-picker * {\n  box-sizing: border-box;\n}\n\n.vue__time-picker input.display-time {\n  border: 1px solid #d2d2d2;\n  width: 10em;\n  height: 2.2em;\n  padding: 0.3em 0.5em;\n  font-size: 1em;\n}\n\n.vue__time-picker input.has-custom-icon {\n  padding-left: 1.8em;\n}\n\n.vue__time-picker input.display-time.invalid:not(.skip-error-style) {\n  border-color: #cc0033;\n  outline-color: #cc0033;\n}\n\n.vue__time-picker input.display-time:disabled,\n.vue__time-picker input.display-time.disabled {\n  color: #d2d2d2;\n}\n\n.vue__time-picker .controls {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  z-index: 3;\n\n  display: flex;\n  flex-flow: row nowrap;\n  justify-content: flex-end;\n  align-items: stretch;\n\n  /* Prevent browser focusing on the controls layer */\n  pointer-events: none;\n}\n\n.vue__time-picker .controls > * {\n  cursor: pointer;\n  \n  width: auto;\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: center;\n  align-items: center;\n\n  padding: 0 0.35em;\n\n  color: #d2d2d2;\n  line-height: 100%;\n  font-style: normal;\n\n  /* Resume pointer-events on children components */\n  pointer-events: initial;\n\n  transition: color .2s, opacity .2s;\n}\n\n.vue__time-picker .controls > *:hover {\n  color: #797979;\n}\n\n.vue__time-picker .controls > *:focus,\n.vue__time-picker .controls > *:active {\n  outline: 0;\n}\n\n.vue__time-picker .controls .char {\n  font-size: 1.1em;\n  line-height: 100%;\n\n  /* Vertical align fixes for webkit browsers only */\n  -webkit-margin-before: -0.15em;\n}\n\n.vue__time-picker .custom-icon {\n  z-index: 2;\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  width: 1.8em;\n\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: center;\n  align-items: center;\n\n  /* pass down mouse events to the <input> underneath */\n  pointer-events: none;\n}\n\n.vue__time-picker .custom-icon img,\n.vue__time-picker .custom-icon svg,\n.vue__time-picker .controls img,\n.vue__time-picker .controls svg {\n  display: inline-block;\n  vertical-align: middle;\n  margin: 0;\n  border: 0;\n  outline: 0;\n  max-width: 1em;\n  height: auto;\n}\n\n.vue__time-picker .time-picker-overlay {\n  z-index: 4;\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.vue__time-picker .dropdown,\n.vue__time-picker-dropdown {\n  position: absolute;\n  z-index: 5;\n  top: calc(2.2em + 2px);\n  left: 0;\n  background: #fff;\n  box-shadow: 0 1px 6px rgba(0,0,0,0.15);\n  width: 10em;\n  height: 10em;\n  font-weight: normal;\n}\n\n/* Dropdown class when \"append-to-body\" is on */\n.vue__time-picker-dropdown {\n  position: fixed;\n  z-index: 100;\n}\n\n.vue__time-picker .dropdown.drop-up,\n.vue__time-picker-dropdown.drop-up {\n  top: auto;\n  bottom: calc(2.2em + 1px);\n}\n\n.vue__time-picker .dropdown .select-list,\n.vue__time-picker-dropdown .select-list {\n  width: 10em;\n  height: 10em;\n  overflow: hidden;\n  display: flex;\n  flex-flow: row nowrap;\n  align-items: stretch;\n  justify-content: space-between;\n}\n\n.vue__time-picker .dropdown .select-list:focus,\n.vue__time-picker .dropdown .select-list:active,\n.vue__time-picker-dropdown .select-list:focus,\n.vue__time-picker-dropdown .select-list:active {\n  outline: 0;\n}\n\n.vue__time-picker .dropdown ul,\n.vue__time-picker-dropdown ul {\n  padding: 0;\n  margin: 0;\n  list-style: none;\n  outline: 0;\n\n  flex: 1 1 0.00001px;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.vue__time-picker .dropdown ul.minutes,\n.vue__time-picker .dropdown ul.seconds,\n.vue__time-picker .dropdown ul.apms,\n.vue__time-picker-dropdown ul.minutes,\n.vue__time-picker-dropdown ul.seconds,\n.vue__time-picker-dropdown ul.apms {\n  border-left: 1px solid #fff;\n}\n\n.vue__time-picker .dropdown ul li,\n.vue__time-picker-dropdown ul li {\n  list-style: none;\n  text-align: center;\n  padding: 0.3em 0;\n  color: #161616;\n}\n\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker .dropdown ul li:not(.hint):not([disabled]):focus,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):hover,\n.vue__time-picker-dropdown ul li:not(.hint):not([disabled]):focus  {\n  background: rgba(0,0,0,.08);\n  color: #161616;\n  cursor: pointer;\n}\n\n.vue__time-picker .dropdown ul li:not([disabled]).active,\n.vue__time-picker .dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker .dropdown ul li:not([disabled]).active:focus,\n.vue__time-picker-dropdown ul li:not([disabled]).active,\n.vue__time-picker-dropdown ul li:not([disabled]).active:hover,\n.vue__time-picker-dropdown ul li:not([disabled]).active:focus {\n  background: #41B883;\n  color: #fff;\n}\n\n.vue__time-picker .dropdown ul li[disabled],\n.vue__time-picker .dropdown ul li[disabled]:hover,\n.vue__time-picker-dropdown ul li[disabled],\n.vue__time-picker-dropdown ul li[disabled]:hover {\n  background: transparent;\n  opacity: 0.3;\n  cursor: not-allowed;\n}\n\n.vue__time-picker .dropdown .hint,\n.vue__time-picker-dropdown .hint {\n  color: #a5a5a5;\n  cursor: default;\n  font-size: 0.8em;\n}\n</style>\n"]}]}